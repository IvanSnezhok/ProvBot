<summary>

<header>
Repopack Output File
This file was generated by Repopack on: 2024-08-23T18:19:47.123Z
</header>

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository structure
3. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
1. This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
2. When processing this file, use the file path attributes to distinguish
  between different files in the repository.
3. Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation.


</notes>

<additional_info>
For more information about Repopack, visit: https://github.com/yamadashy/repopack
</additional_info>

</summary>

<repository_structure>
.gitignore
app.py
data/config.py
data/locales/en/LC_MESSAGES/prov_bot.po
data/locales/ru/LC_MESSAGES/prov_bot.po
data/pays_item.py
dockerfile
filters/__init__.py
filters/group.py
handlers/__init__.py
handlers/errors/__init__.py
handlers/errors/error_handler.py
handlers/groups/__init__.py
handlers/groups/group_panel.py
handlers/users/__init__.py
handlers/users/client_contact.py
handlers/users/contact.py
handlers/users/echo.py
handlers/users/lang_change.py
handlers/users/notify_balance.py
handlers/users/panel.py
handlers/users/pay_bill.py
handlers/users/start.py
handlers/users/time_pay.py
keyboards/__init__.py
keyboards/default/admin.py
keyboards/default/buttons.py
keyboards/inline/callback_datas.py
keyboards/inline/start_keyboard.py
loader.py
middlewares/__init__.py
middlewares/language_middleware.py
middlewares/throttling.py
requirements.txt
states/get_client.py
utils/__init__.py
utils/db_api/database.py
utils/db_api/postgresql.py
utils/format_number.py
utils/misc/__init__.py
utils/misc/find_in_bill.py
utils/misc/logging.py
utils/misc/pay_load.py
utils/misc/sms_message.py
utils/misc/throttling.py
utils/notify_admins.py
utils/telnet.py
</repository_structure>

<repository_files>

<file path=".gitignore">
# Byte-compiled / optimized / DLL files
__pycache__/
*.py[cod]
*$py.class

# C extensions
*.so

# Distribution / packaging
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
pip-wheel-metadata/
share/python-wheels/
*.egg-info/
.installed.cfg
*.egg
MANIFEST

# PyInstaller
#  Usually these files are written by a python script from a template
#  before PyInstaller builds the exe, so as to inject date/other infos into it.
*.manifest
*.spec

# Installer logs
pip-log.txt
pip-delete-this-directory.txt

# Unit test / coverage reports
htmlcov/
.tox/
.nox/
.coverage
.coverage.*
.cache
nosetests.xml
coverage.xml
*.cover
*.py,cover
.hypothesis/
.pytest_cache/

# Translations
*.mo
*.pot

# Django stuff:
*.log
local_settings.py
db.sqlite3
db.sqlite3-journal

# Flask stuff:
instance/
.webassets-cache

# Scrapy stuff:
.scrapy

# Sphinx documentation
docs/_build/

# PyBuilder
target/

# Jupyter Notebook
.ipynb_checkpoints

# IPython
profile_default/
ipython_config.py

# pyenv
.python-version

# pipenv
#   According to pypa/pipenv#598, it is recommended to include Pipfile.lock in version control.
#   However, in case of collaboration, if having platform-specific dependencies or dependencies
#   having no cross-platform support, pipenv may install dependencies that don't work, or not
#   install all needed dependencies.
#Pipfile.lock

# PEP 582; used by e.g. github.com/David-OConnor/pyflow
__pypackages__/

# Celery stuff
celerybeat-schedule
celerybeat.pid

# SageMath parsed files
*.sage.py

# Environments
.venv
*/.env
env/
venv/
ENV/
env.bak/
venv.bak/

# Spyder project settings
.spyderproject
.spyproject

# Rope project settings
.ropeproject

# mkdocs documentation
/site

# mypy
.mypy_cache/
.dmypy.json
dmypy.json

# Pyre type checker
.pyre/
.idea/*
.env.dist
</file>

<file path="app.py">
import logging
from datetime import datetime, date

from aiogram import executor, Dispatcher

from loader import dp, db, scheduler
import middlewares, filters, handlers
from utils.db_api import database
from utils.misc.sms_message import send_message_sms
from utils.notify_admins import on_startup_notify, on_shutdown_notify


async def on_startup(dispatcher):
    # –£–≤–µ–¥–æ–º–ª—è–µ—Ç –ø—Ä–æ –∑–∞–ø—É—Å–∫
    logging.info("–°–æ–∑–¥–∞–µ–º –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ –ª–æ–∫–∞–ª—å–Ω–æ–π –î–ë")
    await db.create()
    logging.info("–°–æ–∑–¥–∞–µ–º —Ç–∞–±–ª–∏—Ü—É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π")
    await db.create_table_users()
    logging.info("–°–æ–∑–¥–∞–µ–º —Ç–∞–±–ª–∏—Ü—É —Å–æ–æ–±—â–µ–Ω–∏–π")
    await db.create_table_msg()
    logging.info("–°–æ–∑–¥–∞–µ–º —Ç–∞–±–ª–∏—Ü—É —Å–∏–≥–Ω–∞–ª–æ–≤")
    await db.create_table_alarm()
    logging.info("–°–æ–∑–¥–∞–µ–º —Ç–∞–±–ª–∏—Ü—É –æ–ø–ª–∞—Ç")
    await db.create_table_bill_check()
    logging.info("–í–∫–ª—é—á–∞–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –ø–æ —Ç–∞–π–º–µ—Ä—É")
    logging.info("–ì–æ—Ç–æ–≤–æ.")
    await on_startup_notify(dispatcher)
    scheduler.add_job(send_message_sms, 'interval', minutes=3)
    scheduler.start()


if __name__ == '__main__':
    executor.start_polling(dp, on_startup=on_startup, on_shutdown=on_shutdown_notify)
</file>

<file path="data/config.py">
from pathlib import Path

from environs import Env

# –¢–µ–ø–µ—Ä—å –∏—Å–ø–æ–ª—å–∑—É–µ–º –≤–º–µ—Å—Ç–æ –±–∏–±–ª–∏–æ—Ç–µ–∫–∏ python-dotenv –±–∏–±–ª–∏–æ—Ç–µ–∫—É environs
env = Env()
env.read_env()

BOT_TOKEN = env.str("BOT_TOKEN")  # –ó–∞–±–∏—Ä–∞–µ–º –∑–Ω–∞—á–µ–Ω–∏–µ —Ç–∏–ø–∞ str
ADMINS = env.list("ADMINS")  # –¢—É—Ç —É –Ω–∞—Å –±—É–¥–µ—Ç —Å–ø–∏—Å–æ–∫ –∏–∑ –∞–¥–º–∏–Ω–æ–≤
IP = env.str("ip")  # –¢–æ–∂–µ str, –Ω–æ –¥–ª—è –∞–π–ø–∏ –∞–¥—Ä–µ—Å–∞ —Ö–æ—Å—Ç–∞

DB_USER = env.str("DB_USER")
DB_PASS = env.str("DB_PASS")
DB_NAME = env.str("DB_NAME")
DB_HOST = env.str("DB_HOST")

PROVIDER_TOKEN = env.str("PROVIDER_TOKEN")

I18N_DOMAIN = "prov_bot"
BASE_DIR = Path(__file__).parent
LOCALES_DIR = BASE_DIR/'locales'

BILL_USER = env.str("BILL_USER")
BILL_PASS = env.str("BILL_PASS")
BILL_NAME = env.str("BILL_NAME")
BILL_HOST = env.str("BILL_HOST")
BILL_PORT = env.str("BILL_PORT")
</file>

<file path="data/locales/en/LC_MESSAGES/prov_bot.po">
# English translations for PROJECT.
# Copyright (C) 2021 ORGANIZATION
# This file is distributed under the same license as the PROJECT project.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2021.
#
msgid ""
msgstr ""
"Project-Id-Version: PROJECT VERSION\n"
"Report-Msgid-Bugs-To: EMAIL@ADDRESS\n"
"POT-Creation-Date: 2021-06-21 07:24+0000\n"
"PO-Revision-Date: 2021-04-30 23:01+0300\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: en\n"
"Language-Team: en <LL@li.org>\n"
"Plural-Forms: nplurals=2; plural=(n != 1)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.9.1\n"

#: handlers/users/echo.py:15
msgid "–î–ª—è –≤–∑–∞—î–º–æ–¥—ñ—ó –∑ –±–æ—Ç–æ–º –Ω–∞—Ç–∏—Å–Ω—ñ—Ç—å –∫–Ω–æ–ø–∫—É"
msgstr "To interact with the bot, you need to press the button"

#: handlers/users/lang_change.py:14
msgid "–û–±–µ—Ä—ñ—Ç—å –º–æ–≤—É"
msgstr "Select a language"

#: handlers/users/lang_change.py:43
msgid ""
"–í–∏ –æ–±—Ä–∞–ª–∏ {}\n"
"–¢–µ–ø–µ—Ä –º–æ–∂–µ—Ç–µ –ø–µ—Ä–µ–π—Ç–∏ —É –≥–æ–ª–æ–≤–Ω–µ –º–µ–Ω—é"
msgstr ""
"You have chosen {}\n"
"Now you can go to the main menu"

#: handlers/users/pay_bill.py:20 handlers/users/pay_bill.py:28
msgid "–ó–≤–µ—Ä–Ω—ñ—Ç—å —É–≤–∞–≥—É, —â–æ —Ç—É—Ç –≤–∏ –º–æ–∂–µ—Ç–µ –ø–æ–ø–æ–≤–Ω–∏—Ç–∏ —Ç—ñ–ª—å–∫–∏ —Å–≤—ñ–π –æ—Å–æ–±–æ–≤–∏–π —Ä–∞—Ö—É–Ω–æ–∫!"
msgstr "Please note that you can only top up your personal account!"

#: handlers/users/pay_bill.py:24 handlers/users/pay_bill.py:33
msgid ""
"–î—ñ—î –∞–∫—Ü—ñ—è - –ø–æ–ø–æ–≤–Ω–∏ —Ä–∞—Ö—É–Ω–æ–∫ –Ω–∞ 6 –º—ñ—Å—è—Ü—ñ–≤ –æ–¥–Ω–∏–º –ø–ª–∞—Ç–µ–∂–µ–º —Ç–∞ –æ—Ç—Ä–∏–º—É–π 10% "
"–≤—ñ–¥ —Å—É–º–∏ –ø–æ–ø–æ–≤–Ω–µ–Ω–Ω—è!"
msgstr ""
"There is a special offer, replenish your account 6 months in advance and "
"get 10% of the replenishment amount!"

#: handlers/users/pay_bill.py:38
msgid "–í–∏–±–∞—á—Ç–µ, –∞–ª–µ –¥–ª—è –≤–∞—à–æ–≥–æ —Ç–∞—Ä–∏—Ñ—É –Ω–µ –ø–µ—Ä–µ–¥–±–∞—á–µ–Ω–æ –ø–æ–ø–æ–≤–Ω–µ–Ω–Ω—è —Ä–∞—Ö—É–Ω–∫—É —á–µ—Ä–µ–∑ –±–æ—Ç"
msgstr "Sorry, but your tariff does not include a top-up via bot"

#: handlers/users/pay_bill.py:59
msgid "–ö–æ—Ä–∏—Å—Ç—É–≤–∞—á {} –ø–æ–ø–æ–≤–Ω–∏–≤ —Ä–∞—Ö—É–Ω–æ–∫ –Ω–∞ {} {}"
msgstr "User {} has deposited an account on {} {}"

#: handlers/users/start.py:23
msgid ""
"–ü—Ä–∏–≤—ñ—Ç, {}!\n"
"–ë–æ—Ç –ø—Ä–∞—Ü—é—î –≤ —Ç–µ—Å—Ç–æ–≤–æ–º—É —Ä–µ–∂–∏–º—ñ"
msgstr ""
"Hi, {}!\n"
"The bot is running in test mode"

#: handlers/users/start.py:35
msgid "–û–±–µ—Ä—ñ—Ç—å –∑—Ä—É—á–Ω—É –¥–ª—è –í–∞—Å –º–æ–≤—É!"
msgstr "Choose a language that is convenient for you!"

#: handlers/users/start.py:47
msgid ""
"–í–∏ –æ–±—Ä–∞–ª–∏ {}\n"
"–¢–µ–ø–µ—Ä –≤—ñ–¥–ø—Ä–∞–≤—Ç–µ, –±—É–¥—å –ª–∞—Å–∫–∞, —Å–≤—ñ–π –Ω–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω—É, —â–æ–± –∑–Ω–∞–π—Ç–∏ –í–∞—à "
"–æ–±–ª—ñ–∫–æ–≤–∏–π –∑–∞–ø–∏—Å —É –Ω–∞—à–æ–º—É –±—ñ–ª—ñ–Ω–≥—É"
msgstr ""
"You choose {}\n"
"Now please send your contact to find you in billing"

#: handlers/users/start.py:51
msgid "–ö–Ω–æ–ø–∫–∞ –¥–ª—è —Ü—å–æ–≥–æ –∑–Ω–∏–∑—É"
msgstr "Button for this at the bottom"

#: handlers/users/start.py:70
msgid "–¢—Ä–µ–±–∞ –Ω–∞—Ç–∏—Å–Ω—É—Ç–∏ –Ω–∞ –∫–Ω–æ–ø–∫—É —â–æ–± –ø–µ—Ä–µ–¥–∞—Ç–∏ –Ω–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω—É"
msgstr "You need to press the button to send your phone number"

#: handlers/users/start.py:64 handlers/users/start.py:91
msgid ""
"–í–∞—à username: {}\n"
"–ù–∞ –≤–∞—à–æ–º—É —Ä–∞—Ö—É–Ω–∫—É: {}\n"
"–í–∞—à –Ω–æ–º–µ—Ä –¥–æ–≥–æ–≤–æ—Ä—É: {}\n"
"–í–∞—à–µ –ü–Ü–ë: {}\n"
"–°—Ç–∞–Ω –ø–æ—Å–ª—É–≥–∏: {}\n"
"–í–∞—à –ø–∞–∫–µ—Ç: {}"
msgstr ""
"Your username: {} \n"
"In your account: {} \n"
"Your contract number: {} \n"
"Your full name: {} \n"
"Service status: {} \n"
"Your package: {}"

#: handlers/users/start.py:75 handlers/users/start.py:102
msgid ""
"–í–∫–∞–∑–∞–Ω–∏–π –Ω–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω—É –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–æ —É –Ω–∞—à–æ–º—É –±—ñ–ª—ñ–Ω–≥—É\n"
"–Ø–∫—â–æ –≤–∏ –±–∞–∂–∞—î—Ç–µ –ø—ñ–¥–∫–ª—é—á–∏—Ç–∏—Å—è - –∑–∞–ª–∏—à—Ç–µ –∑–∞—è–≤–∫—É –Ω–∞ –ø—ñ–¥–∫–ª—é—á–µ–Ω–Ω—è –Ω–∞—Ç–∏—Å–Ω—É–≤—à–∏ "
"–∫–Ω–æ–ø–∫—É"
msgstr ""
"Wee are not registered in our billing\n"
"If you want to connect, leave a request for connection by pressing the "
"button\n"
" "

#: handlers/users/start.py:111
msgid "–í–≤–µ–¥—ñ—Ç—å –≤–∞—à–µ –ü–Ü–ë, –Ω–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω—É —Ç–∞ –æ–ø–∏—à—ñ—Ç—å –ø—Ä–æ–±–ª–µ–º—É"
msgstr "Enter your full name, phone number and describe your problem"

#: handlers/users/start.py:131 handlers/users/start.py:161
msgid ""
"–ó–∞—è–≤–∫–∞ –≤ –æ–ø—Ä–∞—Ü—é–≤–∞–Ω–Ω—ñ, —á–µ–∫–∞–π—Ç–µ –∑–≤'—è–∑–∫—É\n"
"–ú–æ–∂–µ—Ç–µ –ø–æ–≤–µ—Ä–Ω—É—Ç–∏—Å—å —É –≥–æ–ª–æ–≤–Ω–µ –º–µ–Ω—é —Å–∫–æ—Ä–∏—Å—Ç–∞–≤—à–∏—Å—å –∫–Ω–æ–ø–∫–æ—é –∑–Ω–∏–∑—É"
msgstr ""
"Your application is being processed, we will contact you \n"
"You can return to the main menu by clicking the button below"

#: handlers/users/start.py:141
msgid "–í–≤–µ–¥—ñ—Ç—å –ü–Ü–ë —Ç–∞ –Ω–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω—É - –º–∏ –∑–≤'—è–∂–µ–º–æ—Å—å –∑ –í–∞–º–∏ –¥–ª—è –ø—ñ–¥–∫–ª—é—á–µ–Ω–Ω—è"
msgstr ""
"Enter your full name and phone number, we will contact you to discuss "
"your connection \n"

#: handlers/users/time_pay.py:14
msgid ""
"–î–æ—Å—Ç—É–ø –≤ –Ü–Ω—Ç–µ—Ä–Ω–µ—Ç —Ä–æ–∑–±–ª–æ–∫–æ–≤–∞–Ω–æ –Ω–∞ 24 –≥–æ–¥–∏–Ω–∏!\n"
"–†–∞—Ö—É–Ω–æ–∫ –ø–æ–ø–æ–≤–Ω–µ–Ω–æ –Ω–∞ {} –≥—Ä–Ω –Ω–∞ 24 –≥–æ–¥–∏–Ω–∏! –¢–µ–ø–µ—Ä –º–æ–∂–µ—Ç–µ –ø–æ–≤–µ—Ä–Ω—É—Ç–∏—Å—å —É "
"–≥–æ–ª–æ–≤–Ω–µ –º–µ–Ω—é"
msgstr ""
"Internet access is unlocked for 24 hours!\n"
"Account replenished by {} UAH for 24 hours! Now you can return tomain menu"

#: handlers/users/time_pay.py:19
msgid ""
"–í–∏ –Ω–µ –º–æ–∂–µ—Ç–µ –≤–∏–∫–æ—Ä–∏—Å—Ç–∞—Ç–∏ —Ç–∏–º—á–∞—Å–æ–≤–∏–π –ø–ª–∞—Ç—ñ–∂!\n"
"–ö–æ—Ä–∏—Å—Ç—É–≤–∞—Ç–∏—Å—å —Ç–∏–º—á–∞—Å–æ–≤–∏–º –ø–ª–∞—Ç–µ–∂–µ–º –º–æ–∂–Ω–∞ —Ä–∞–∑ –Ω–∞ –º—ñ—Å—è—Ü—å!"
msgstr ""
"You cannot make a temporary payment now!\n"
"You can only use the temporary payment once a month!"

msgid "–ü–æ–ø–æ–≤–Ω–∏—Ç–∏ —Ä–∞—Ö—É–Ω–æ–∫"
msgstr "Top up account"

msgid "–í–∞—à —Ä–∞—Ö—É–Ω–æ–∫ –ø–æ–ø–æ–≤–Ω–µ–Ω–æ –Ω–∞ {} {}!"
msgstr "Your account has been credited to {} {}!"

msgid "–ì–æ–ª–æ–≤–Ω–µ –º–µ–Ω—é"
msgstr "Main menu"

msgid "–ü–æ–≤—ñ–¥–æ–º–∏—Ç–∏ –ø—Ä–æ –ø—Ä–æ–±–ª–µ–º—É"
msgstr "Report an issue"

msgid "–ó–∞–ª–∏—à–∏—Ç–∏ –∑–∞—è–≤–∫—É –Ω–∞ –ø—ñ–¥–∫–ª—é—á–µ–Ω–Ω—è"
msgstr "Leave a request for connection"

msgid "–ó–º—ñ–Ω–∏—Ç–∏ –º–æ–≤—É"
msgstr "Change the language"

msgid "–¢–∏–º—á–∞—Å–æ–≤–∏–π –ø–ª–∞—Ç—ñ–∂"
msgstr "Temporary payment"

msgid "@infoaura_bot - –±–æ—Ç –º–µ—Ä–µ–∂—ñ —ñ–Ω—Ç–µ—Ä–Ω–µ—Ç-–ø—Ä–æ–≤–∞–π–¥–µ—Ä–∞ –Ü–Ω—Ñ–æ–∞—É—Ä–∞.\n"
       "–ë–æ—Ç –ø—Ä–∏–∑–Ω–∞—á–µ–Ω–∏–π –¥–ª—è –¥–æ—Å—Ç—É–ø–Ω–æ–≥–æ —É–ø—Ä–∞–≤–ª—ñ–Ω–Ω—è–º –ø–æ—Å–ª—É–≥–∞–º–∏, –ø–æ–ø–æ–≤–Ω–µ–Ω–Ω—è —Ä–∞—Ö—É–Ω–∫—É —ñ –≤–∏–∫–ª–∏–∫—É —Ñ–∞—Ö—ñ–≤—Ü—è –¥–ª—è –≤–∏—Ä—ñ—à–µ–Ω–Ω—è –ª–æ–∫–∞–ª—å–Ω–∏—Ö –ø—Ä–æ–±–ª–µ–º –ö–ª—ñ—î–Ω—Ç–∞.\n"
       "–ü—Ä–æ–ø–æ–∑–∏—Ü—ñ—ó —Ç–∞ –∑–∞—É–≤–∞–∂–µ–Ω–Ω—è –ø–æ —Ä–æ–±–æ—Ç—ñ –±–æ—Ç–∞ –ø—Ä–æ—Å–∏–º–æ –ø–∏—Å–∞—Ç–∏ –Ω–∞ email: bot@infoaura.com.ua."
msgstr "@infoaura_bot is the bot of the network provider Infoaura.\n"
        "The bot is designed to be accessible to service management, account replenishment and call a specialist to solve local problems of the Client.\n"
        "Suggestions and comments on the work of the bot, please write to email: bot@infoaura.com.ua."

msgid "–£–≤—ñ–º–∫–Ω–µ–Ω–æ"
msgstr "Enabled"

msgid "–í–∏–º–∫–Ω–µ–Ω–æ"
msgstr "Off"

#: keyboards/default/buttons.py:7
msgid "–í—ñ–¥–ø—Ä–∞–≤–∏—Ç–∏ –Ω–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω—É"
msgstr "Send phone number"
</file>

<file path="data/locales/ru/LC_MESSAGES/prov_bot.po">
# Russian translations for PROJECT.
# Copyright (C) 2021 ORGANIZATION
# This file is distributed under the same license as the PROJECT project.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2021.
#
msgid ""
msgstr ""
"Project-Id-Version: PROJECT VERSION\n"
"Report-Msgid-Bugs-To: EMAIL@ADDRESS\n"
"POT-Creation-Date: 2021-06-21 07:24+0000\n"
"PO-Revision-Date: 2021-04-30 23:02+0300\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: ru\n"
"Language-Team: ru <LL@li.org>\n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && "
"n%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.9.1\n"

#: handlers/users/echo.py:15
msgid "–î–ª—è –≤–∑–∞—î–º–æ–¥—ñ—ó –∑ –±–æ—Ç–æ–º –Ω–∞—Ç–∏—Å–Ω—ñ—Ç—å –∫–Ω–æ–ø–∫—É"
msgstr "–î–ª—è –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏—è —Å –±–æ—Ç–æ–º –Ω–∞–∂–º–∏—Ç–µ –∫–Ω–æ–ø–∫—É"

#: handlers/users/lang_change.py:14
msgid "–û–±–µ—Ä—ñ—Ç—å –º–æ–≤—É"
msgstr "–í—ã–±–µ—Ä–µ—Ç–µ —è–∑—ã–∫"

#: handlers/users/lang_change.py:43
msgid ""
"–í–∏ –æ–±—Ä–∞–ª–∏ {}\n"
"–¢–µ–ø–µ—Ä –º–æ–∂–µ—Ç–µ –ø–µ—Ä–µ–π—Ç–∏ —É –≥–æ–ª–æ–≤–Ω–µ –º–µ–Ω—é"
msgstr ""
"–í—ã –≤—ã–±—Ä–∞–ª–∏ {}\n"
"–¢–µ–ø–µ—Ä—å –º–æ–∂–µ—Ç–µ –ø–µ—Ä–µ–π—Ç–∏ –≤ –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é"

#: handlers/users/start.py:70
msgid "–¢—Ä–µ–±–∞ –Ω–∞—Ç–∏—Å–Ω—É—Ç–∏ –Ω–∞ –∫–Ω–æ–ø–∫—É —â–æ–± –ø–µ—Ä–µ–¥–∞—Ç–∏ –Ω–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω—É"
msgstr "–ù–∞–∂–º–∏—Ç–µ –Ω–∞ –∫–Ω–æ–ø–∫—É —á—Ç–æ–±—ã –ø–µ—Ä–µ–¥–∞—Ç—å –Ω–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω–∞"

#: handlers/users/pay_bill.py:20 handlers/users/pay_bill.py:28
msgid "–ó–≤–µ—Ä–Ω—ñ—Ç—å —É–≤–∞–≥—É, —â–æ —Ç—É—Ç –≤–∏ –º–æ–∂–µ—Ç–µ –ø–æ–ø–æ–≤–Ω–∏—Ç–∏ —Ç—ñ–ª—å–∫–∏ —Å–≤—ñ–π –æ—Å–æ–±–æ–≤–∏–π —Ä–∞—Ö—É–Ω–æ–∫!"
msgstr "–û–±—Ä–∞—Ç–∏—Ç–µ –≤–Ω–∏–º–∞–Ω–∏–µ, —á—Ç–æ –≤—ã –º–æ–∂–µ—Ç–µ –ø–æ–ø–æ–ª–Ω–∏—Ç—å —Ç–æ–ª—å–∫–æ —Å–≤–æ–π –ª–∏—Ü–µ–≤–æ–π —Å—á–µ—Ç!"

#: handlers/users/pay_bill.py:24 handlers/users/pay_bill.py:33
msgid ""
"–î—ñ—î –∞–∫—Ü—ñ—è - –ø–æ–ø–æ–≤–Ω–∏ —Ä–∞—Ö—É–Ω–æ–∫ –Ω–∞ 6 –º—ñ—Å—è—Ü—ñ–≤ –æ–¥–Ω–∏–º –ø–ª–∞—Ç–µ–∂–µ–º —Ç–∞ –æ—Ç—Ä–∏–º—É–π 10% "
"–≤—ñ–¥ —Å—É–º–∏ –ø–æ–ø–æ–≤–Ω–µ–Ω–Ω—è!"
msgstr ""
"–î–µ–π—Å—Ç–≤—É–µ—Ç –∞–∫—Ü–∏—è - –ø–æ–ø–æ–ª–Ω–∏ —Å—á–µ—Ç –Ω–∞ 6 –º–µ—Å—è—Ü–µ–≤ –æ–¥–Ω–∏–º –ø–ª–∞—Ç–µ–∂–æ–º –∏ –ø–æ–ª—É—á–∏—Ç–µ 10%"
" –æ—Ç —Å—É–º–º—ã –ø–æ–ø–æ–ª–Ω–µ–Ω–∏—è!"

#: handlers/users/pay_bill.py:38
msgid "–í–∏–±–∞—á—Ç–µ, –∞–ª–µ –¥–ª—è –≤–∞—à–æ–≥–æ —Ç–∞—Ä–∏—Ñ—É –Ω–µ –ø–µ—Ä–µ–¥–±–∞—á–µ–Ω–æ –ø–æ–ø–æ–≤–Ω–µ–Ω–Ω—è —Ä–∞—Ö—É–Ω–∫—É —á–µ—Ä–µ–∑ –±–æ—Ç"
msgstr "–ò–∑–≤–∏–Ω–∏—Ç–µ, –Ω–æ –¥–ª—è –≤–∞—à–µ–≥–æ —Ç–∞—Ä–∏—Ñ–∞ –Ω–µ –ø—Ä–µ–¥—É—Å–º–æ—Ç—Ä–µ–Ω–æ –ø–æ–ø–æ–ª–Ω–µ–Ω–∏–µ —Å—á–µ—Ç–∞ –≤ –±–æ—Ç–µ"

#: handlers/users/pay_bill.py:59
msgid "–ö–æ—Ä–∏—Å—Ç—É–≤–∞—á {} –ø–æ–ø–æ–≤–Ω–∏–≤ —Ä–∞—Ö—É–Ω–æ–∫ –Ω–∞ {} {}"
msgstr "–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å {} –ø–æ–ø–æ–ª–Ω–∏–ª —Å—á–µ—Ç –Ω–∞ {} {}"

#: handlers/users/start.py:23
msgid ""
"–ü—Ä–∏–≤—ñ—Ç, {}!\n"
"–ë–æ—Ç –ø—Ä–∞—Ü—é—î –≤ —Ç–µ—Å—Ç–æ–≤–æ–º—É —Ä–µ–∂–∏–º—ñ"
msgstr ""
"–ó—Ä–∞–≤—Å—Ç–≤—É–π—Ç–µ, {}!\n"
"–ë–æ—Ç —Ä–∞–±–æ—Ç–∞–µ—Ç –≤ —Ç–µ—Å—Ç–æ–≤–æ–º —Ä–µ–∂–∏–º–µ"

#: handlers/users/start.py:35
msgid "–û–±–µ—Ä—ñ—Ç—å –∑—Ä—É—á–Ω—É –¥–ª—è –í–∞—Å –º–æ–≤—É!"
msgstr "–í—ã–±–µ—Ä–∏—Ç–µ —É–¥–æ–±–Ω—ã–π –¥–ª—è –í–∞—Å —è–∑—ã–∫!"

#: handlers/users/start.py:47
msgid ""
"–í–∏ –æ–±—Ä–∞–ª–∏ {}\n"
"–¢–µ–ø–µ—Ä –≤—ñ–¥–ø—Ä–∞–≤—Ç–µ, –±—É–¥—å –ª–∞—Å–∫–∞, —Å–≤—ñ–π –Ω–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω—É, —â–æ–± –∑–Ω–∞–π—Ç–∏ –í–∞—à "
"–æ–±–ª—ñ–∫–æ–≤–∏–π –∑–∞–ø–∏—Å —É –Ω–∞—à–æ–º—É –±—ñ–ª—ñ–Ω–≥—É"
msgstr ""
"–í—ã –≤—ã–±—Ä–∞–ª–∏ {}\n"
"–¢–µ–ø–µ—Ä—å –ø–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ—Ç–ø—Ä–∞–≤—å—Ç–µ –í–∞—à –Ω–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω–∞, —á—Ç–æ–±—ã –Ω–∞–π—Ç–∏ –í–∞—à—É —É—á–µ—Ç–Ω—É—é"
" –∑–∞–ø–∏—Å—å –≤ –Ω–∞—à–µ–º –±–∏–ª–ª–∏–Ω–≥–µ"

#: handlers/users/start.py:51
msgid "–ö–Ω–æ–ø–∫–∞ –¥–ª—è —Ü—å–æ–≥–æ –∑–Ω–∏–∑—É"
msgstr "–ö–Ω–æ–ø–∫–∞ –¥–ª—è —ç—Ç–æ–≥–æ —Å–Ω–∏–∑—É"

#: handlers/users/start.py:64 handlers/users/start.py:91
msgid ""
"–í–∞—à username: {}\n"
"–ù–∞ –≤–∞—à–æ–º—É —Ä–∞—Ö—É–Ω–∫—É: {}\n"
"–í–∞—à –Ω–æ–º–µ—Ä –¥–æ–≥–æ–≤–æ—Ä—É: {}\n"
"–í–∞—à–µ –ü–Ü–ë: {}\n"
"–°—Ç–∞–Ω –ø–æ—Å–ª—É–≥–∏: {}\n"
"–í–∞—à –ø–∞–∫–µ—Ç: {}"
msgstr ""
"–í–∞—à username: {}\n"
"–ù–∞ –≤–∞—à–µ–º —Å—á–µ—Ç—É: {}\n"
"–í–∞—à –Ω–æ–º–µ—Ä –¥–æ–≥–æ–≤–æ—Ä–∞: {}\n"
"–í–∞—à–µ –§–ò–û: {}\n"
"–°–æ—Å—Ç–æ—è–Ω–∏–µ —É—Å–ª—É–≥–∏: {}\n"
"–í–∞—à –ø–∞–∫–µ—Ç: {}\n"

#: handlers/users/start.py:75 handlers/users/start.py:102
msgid ""
"–í–∫–∞–∑–∞–Ω–∏–π –Ω–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω—É –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–æ —É –Ω–∞—à–æ–º—É –±—ñ–ª—ñ–Ω–≥—É\n"
"–Ø–∫—â–æ –≤–∏ –±–∞–∂–∞—î—Ç–µ –ø—ñ–¥–∫–ª—é—á–∏—Ç–∏—Å—è - –∑–∞–ª–∏—à—Ç–µ –∑–∞—è–≤–∫—É –Ω–∞ –ø—ñ–¥–∫–ª—é—á–µ–Ω–Ω—è –Ω–∞—Ç–∏—Å–Ω—É–≤—à–∏ "
"–∫–Ω–æ–ø–∫—É"
msgstr ""
"–í–∞—à –Ω–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ –Ω–∞—à–µ–º –±–∏–ª–ª–∏–Ω–≥–µ\n"
"–ï—Å–ª–∏ –≤—ã —Ö–æ—Ç–∏—Ç–µ –ø–æ–¥–∫–ª—é—á–∏—Ç—å—Å—è - –æ—Å—Ç–∞–≤—Ç–µ –∑–∞—è–≤–∫—É –Ω–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –Ω–∞–∂–∞—Ç–∏–µ–º "
"–∫–Ω–æ–ø–∫–∏\n"

#: handlers/users/start.py:111
msgid "–í–≤–µ–¥—ñ—Ç—å –≤–∞—à–µ –ü–Ü–ë, –Ω–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω—É —Ç–∞ –æ–ø–∏—à—ñ—Ç—å –ø—Ä–æ–±–ª–µ–º—É"
msgstr "–í–≤–µ–¥–∏—Ç–µ –≤–∞—à–µ –§–ò–û, –Ω–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω–∞ –∏ –æ–ø–∏—à–∏—Ç–µ –ø—Ä–æ–±–ª–µ–º—É"

#: handlers/users/start.py:131 handlers/users/start.py:161
msgid ""
"–ó–∞—è–≤–∫–∞ –≤ –æ–ø—Ä–∞—Ü—é–≤–∞–Ω–Ω—ñ, —á–µ–∫–∞–π—Ç–µ –∑–≤'—è–∑–∫—É\n"
"–ú–æ–∂–µ—Ç–µ –ø–æ–≤–µ—Ä–Ω—É—Ç–∏—Å—å —É –≥–æ–ª–æ–≤–Ω–µ –º–µ–Ω—é —Å–∫–æ—Ä–∏—Å—Ç–∞–≤—à–∏—Å—å –∫–Ω–æ–ø–∫–æ—é –∑–Ω–∏–∑—É"
msgstr ""
"–ó–∞—è–≤–∫–∞ –≤ –æ–±—Ä–∞–±–æ—Ç–∫–µ, –º—ã —Å –í–∞–º–∏ —Å–≤—è–∂–µ–º—Å—è\n"
"–ú–æ–∂–µ—Ç–µ –≤–µ—Ä–Ω—É—Ç—å—Å—è –≤ –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é –Ω–∞–∂–∞–≤ –∫–Ω–æ–ø–∫—É –≤–Ω–∏–∑—É"

#: handlers/users/start.py:141
msgid "–í–≤–µ–¥—ñ—Ç—å –ü–Ü–ë —Ç–∞ –Ω–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω—É - –º–∏ –∑–≤'—è–∂–µ–º–æ—Å—å –∑ –í–∞–º–∏ –¥–ª—è –ø—ñ–¥–∫–ª—é—á–µ–Ω–Ω—è"
msgstr "–í–≤–µ–¥–∏—Ç–µ –§–ò–û –∏ –Ω–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω–∞, –º—ã —Å –í–∞–º–∏ —Å–≤—è–∂–µ–º—Å—è —á—Ç–æ–±—ã –æ–±—Å—É–¥–∏—Ç—å "
"–ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ"

#: handlers/users/time_pay.py:14
msgid ""
"–î–æ—Å—Ç—É–ø –≤ –Ü–Ω—Ç–µ—Ä–Ω–µ—Ç —Ä–æ–∑–±–ª–æ–∫–æ–≤–∞–Ω–æ –Ω–∞ 24 –≥–æ–¥–∏–Ω–∏!\n"
"–†–∞—Ö—É–Ω–æ–∫ –ø–æ–ø–æ–≤–Ω–µ–Ω–æ –Ω–∞ {} –≥—Ä–Ω –Ω–∞ 24 –≥–æ–¥–∏–Ω–∏! –¢–µ–ø–µ—Ä –º–æ–∂–µ—Ç–µ –ø–æ–≤–µ—Ä–Ω—É—Ç–∏—Å—å —É "
"–≥–æ–ª–æ–≤–Ω–µ –º–µ–Ω—é"
msgstr ""
"–î–æ—Å—Ç—É–ø –≤ –∏–Ω—Ç–µ—Ä–Ω–µ—Ç —Ä–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω –Ω–∞ 24 —á–∞—Å–∞!\n"
"–°—á–µ—Ç –ø–æ–ø–æ–ª–Ω–µ–Ω –Ω–∞ {} –≥—Ä–Ω –Ω–∞ 24 —á–∞—Å–∞! –¢–µ–ø–µ—Ä—å –º–æ–∂–µ—Ç–µ –≤–µ—Ä–Ω—É—Ç—å—Å—è –≤ –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é"

#: handlers/users/time_pay.py:19
msgid ""
"–í–∏ –Ω–µ –º–æ–∂–µ—Ç–µ –≤–∏–∫–æ—Ä–∏—Å—Ç–∞—Ç–∏ —Ç–∏–º—á–∞—Å–æ–≤–∏–π –ø–ª–∞—Ç—ñ–∂!\n"
"–ö–æ—Ä–∏—Å—Ç—É–≤–∞—Ç–∏—Å—å —Ç–∏–º—á–∞—Å–æ–≤–∏–º –ø–ª–∞—Ç–µ–∂–µ–º –º–æ–∂–Ω–∞ —Ä–∞–∑ –Ω–∞ –º—ñ—Å—è—Ü—å!"
msgstr ""
"–í—ã –Ω–µ –º–æ–∂–µ—Ç–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –≤—Ä–µ–º–µ–Ω–Ω—ã–π –ø–ª–∞—Ç–µ–∂!\n"
"–ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –≤—Ä–µ–º–µ–Ω–Ω—ã–π –ø–ª–∞—Ç–µ–∂ –º–æ–∂–Ω–æ —Ä–∞–∑ –≤ –º–µ—Å—è—Ü!"

msgid "–ü–æ–ø–æ–≤–Ω–∏—Ç–∏ —Ä–∞—Ö—É–Ω–æ–∫"
msgstr "–ü–æ–ø–æ–ª–Ω–∏—Ç—å —Å—á–µ—Ç"

msgid "–í–∞—à —Ä–∞—Ö—É–Ω–æ–∫ –ø–æ–ø–æ–≤–Ω–µ–Ω–æ –Ω–∞ {} {}!"
msgstr "–í–∞—à —Å—á–µ—Ç –ø–æ–ø–æ–ª–Ω–µ–Ω –Ω–∞ {} {}!"

msgid "–ì–æ–ª–æ–≤–Ω–µ –º–µ–Ω—é"
msgstr "–ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é"

msgid "–ü–æ–≤—ñ–¥–æ–º–∏—Ç–∏ –ø—Ä–æ –ø—Ä–æ–±–ª–µ–º—É"
msgstr "–°–æ–æ–±—â–∏—Ç—å –æ –ø—Ä–æ–±–ª–µ–º–µ"

msgid "–ó–∞–ª–∏—à–∏—Ç–∏ –∑–∞—è–≤–∫—É –Ω–∞ –ø—ñ–¥–∫–ª—é—á–µ–Ω–Ω—è"
msgstr "–û—Å—Ç–∞–≤–∏—Ç—å –∑–∞—è–≤–∫—É –Ω–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ"

msgid "–ó–º—ñ–Ω–∏—Ç–∏ –º–æ–≤—É"
msgstr "–°–º–µ–Ω–∏—Ç—å —è–∑—ã–∫"

msgid "–¢–∏–º—á–∞—Å–æ–≤–∏–π –ø–ª–∞—Ç—ñ–∂"
msgstr "–í—Ä–µ–º–µ–Ω–Ω—ã–π –ø–ª–∞—Ç–µ–∂"

#: handlers/users/start.py:44
msgid "@infoaura_bot - –±–æ—Ç –º–µ—Ä–µ–∂—ñ —ñ–Ω—Ç–µ—Ä–Ω–µ—Ç-–ø—Ä–æ–≤–∞–π–¥–µ—Ä–∞ –Ü–Ω—Ñ–æ–∞—É—Ä–∞.\n"
       "–ë–æ—Ç –ø—Ä–∏–∑–Ω–∞—á–µ–Ω–∏–π –¥–ª—è –¥–æ—Å—Ç—É–ø–Ω–æ–≥–æ —É–ø—Ä–∞–≤–ª—ñ–Ω–Ω—è–º –ø–æ—Å–ª—É–≥–∞–º–∏, –ø–æ–ø–æ–≤–Ω–µ–Ω–Ω—è —Ä–∞—Ö—É–Ω–∫—É —ñ –≤–∏–∫–ª–∏–∫—É —Ñ–∞—Ö—ñ–≤—Ü—è –¥–ª—è –≤–∏—Ä—ñ—à–µ–Ω–Ω—è –ª–æ–∫–∞–ª—å–Ω–∏—Ö –ø—Ä–æ–±–ª–µ–º –ö–ª—ñ—î–Ω—Ç–∞.\n"
       "–ü—Ä–æ–ø–æ–∑–∏—Ü—ñ—ó —Ç–∞ –∑–∞—É–≤–∞–∂–µ–Ω–Ω—è –ø–æ —Ä–æ–±–æ—Ç—ñ –±–æ—Ç–∞ –ø—Ä–æ—Å–∏–º–æ –ø–∏—Å–∞—Ç–∏ –Ω–∞ email: bot@infoaura.com.ua."
msgstr "@infoaura_bot - –±–æ—Ç —Å–µ—Ç–∏ –∏–Ω—Ç–µ—Ä–Ω–µ—Ç-–ø—Ä–æ–≤–∞–π–¥–µ—Ä–∞ –ò–Ω—Ñ–æ–∞—É—Ä–∞.\n"
       "–ë–æ—Ç –ø—Ä–µ–¥–Ω–∞–∑–Ω–∞—á–µ–Ω –¥–ª—è –¥–æ—Å—Ç—É–ø–Ω–æ–≥–æ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è–º —É—Å–ª—É–≥–∞–º–∏, –ø–æ–ø–æ–ª–Ω–µ–Ω–∏—è —Å—á–µ—Ç–∞ –∏ –≤—ã–∑–æ–≤–∞ —Å–ø–µ—Ü–∏–∞–ª–∏—Å—Ç–∞ –¥–ª—è —Ä–µ—à–µ–Ω–∏—è –ª–æ–∫–∞–ª—å–Ω—ã—Ö –ø—Ä–æ–±–ª–µ–º –ö–ª–∏–µ–Ω—Ç–∞.\n"
       "–ü—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è –∏ –∑–∞–º–µ—á–∞–Ω–∏—è –ø–æ —Ä–∞–±–æ—Ç–µ –±–æ—Ç–∞ –ø—Ä–æ—Å–∏–º –ø–∏—Å–∞—Ç—å –Ω–∞ email: bot@infoaura.com.ua."

msgid "–£–≤—ñ–º–∫–Ω–µ–Ω–æ"
msgstr "–í–∫–ª—é—á–µ–Ω–∞"

msgid "–í–∏–º–∫–Ω–µ–Ω–æ"
msgstr "–í—ã–∫–ª—é—á–µ–Ω–∞"

#: keyboards/default/buttons.py:7
msgid "–í—ñ–¥–ø—Ä–∞–≤–∏—Ç–∏ –Ω–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω—É"
msgstr "–û—Ç–ø—Ä–∞–≤–∏—Ç—å –Ω–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω–∞"
</file>

<file path="data/pays_item.py">
import uuid

from aiogram.types import LabeledPrice

from utils.misc.pay_load import Pay


P180 = Pay(
    title="–ü–æ–ø–æ–≤–Ω–µ–Ω–Ω—è –Ω–∞ 180 –≥—Ä–Ω",
    description="–ü–æ–ø–æ–≤–Ω–µ–Ω–Ω—è —Ä–∞—Ö—É–Ω–∫—É –Ω–∞ 180 –≥—Ä–∏–≤–µ–Ω—å",
    currency="UAH",
    prices=[
        LabeledPrice(
            label="180",
            amount=180_00
        )
    ],
    start_parameter=f"create_invoice_180_{uuid.uuid4()}"
)

P1080 = Pay(
    title="–ü–æ–ø–æ–≤–Ω–µ–Ω–Ω—è –Ω–∞ 1080 –≥—Ä–Ω",
    description="–ü–æ–ø–æ–≤–Ω–µ–Ω–Ω—è —Ä–∞—Ö—É–Ω–∫—É –Ω–∞ 1080 –≥—Ä–∏–≤–µ–Ω—å",
    currency="UAH",
    prices=[
        LabeledPrice(
            label="1080",
            amount=1080_00
        )
    ],
    start_parameter=f"create_invoice_1080_{uuid.uuid4()}"
)

P200 = Pay(
    title="–ü–æ–ø–æ–≤–Ω–µ–Ω–Ω—è –Ω–∞ 200 –≥—Ä–Ω",
    description="–ü–æ–ø–æ–≤–Ω–µ–Ω–Ω—è —Ä–∞—Ö—É–Ω–∫—É –Ω–∞ 200 –≥—Ä–∏–≤–µ–Ω—å",
    currency="UAH",
    prices=[
        LabeledPrice(
            label="200",
            amount=200_00
        )
    ],
    start_parameter=f"create_invoice_200_{uuid.uuid4()}"
)

P1200 = Pay(
    title="–ü–æ–ø–æ–≤–Ω–µ–Ω–Ω—è –Ω–∞ 1200 –≥—Ä–Ω",
    description="–ü–æ–ø–æ–≤–Ω–µ–Ω–Ω—è —Ä–∞—Ö—É–Ω–∫—É –Ω–∞ 1200 –≥—Ä–∏–≤–µ–Ω—å",
    currency="UAH",
    prices=[
        LabeledPrice(
            label="1200",
            amount=1200_00
        )
    ],
    start_parameter=f"create_invoice_1200_{uuid.uuid4()}"
)

P350 = Pay(
    title="–ü–æ–ø–æ–≤–Ω–µ–Ω–Ω—è –Ω–∞ 350 –≥—Ä–Ω",
    description="–ü–æ–ø–æ–≤–Ω–µ–Ω–Ω—è —Ä–∞—Ö—É–Ω–∫—É –Ω–∞ 350 –≥—Ä–∏–≤–µ–Ω—å",
    currency="UAH",
    prices=[
        LabeledPrice(
            label="350",
            amount=350_00
        )
    ],
    start_parameter=f"create_invoice_350_{uuid.uuid4()}"
)

P2100 = Pay(
    title="–ü–æ–ø–æ–≤–Ω–µ–Ω–Ω—è –Ω–∞ 2100 –≥—Ä–Ω",
    description="–ü–æ–ø–æ–≤–Ω–µ–Ω–Ω—è —Ä–∞—Ö—É–Ω–∫—É –Ω–∞ 2100 –≥—Ä–∏–≤–µ–Ω—å",
    currency="UAH",
    prices=[
        LabeledPrice(
            label="2100",
            amount=2100_00
        )
    ],
    start_parameter=f"create_invoice_2100_{uuid.uuid4()}"
)
</file>

<file path="dockerfile">
FROM python:3.9-slim-bullseye

ENV VIRTUAL_ENV=/opt/venv
RUN python3 -m venv $VIRTUAL_ENV
ENV PATH="$VIRTUAL_ENV/bin:$PATH"

# Install dependencies:
COPY requirements.txt .
RUN pip install -r requirements.txt

# Run the application:
COPY app.py .
CMD ["python", "app.py"]
</file>

<file path="filters/__init__.py">
from aiogram import Dispatcher

from loader import dp
from .group import IsGroup


if __name__ == "filters":
    dp.filters_factory.bind(IsGroup)
    pass
</file>

<file path="filters/group.py">
from aiogram import types
from aiogram.dispatcher.filters import BoundFilter


class IsGroup(BoundFilter):

    async def check(self, message: types.Message) -> bool:
        return message.chat.type in (types.ChatType.GROUP, types.ChatType.SUPER_GROUP)
</file>

<file path="handlers/__init__.py">
from .errors import dp
from .users import dp

__all__ = ["dp"]
</file>

<file path="handlers/errors/__init__.py">
from .error_handler import dp

__all__ = ["dp"]
</file>

<file path="handlers/errors/error_handler.py">
import logging
from aiogram.utils.exceptions import (Unauthorized, InvalidQueryID, TelegramAPIError,
                                      CantDemoteChatCreator, MessageNotModified, MessageToDeleteNotFound,
                                      MessageTextIsEmpty, RetryAfter,
                                      CantParseEntities, MessageCantBeDeleted)


from loader import dp


@dp.errors_handler()
async def errors_handler(update, exception):
    """
    Exceptions handler. Catches all exceptions within task factory tasks.
    :param dispatcher:
    :param update:
    :param exception:
    :return: stdout logging
    """

    if isinstance(exception, CantDemoteChatCreator):
        logging.debug("Can't demote chat creator")
        return True

    if isinstance(exception, MessageNotModified):
        logging.debug('Message is not modified')
        return True
    if isinstance(exception, MessageCantBeDeleted):
        logging.debug('Message cant be deleted')
        return True

    if isinstance(exception, MessageToDeleteNotFound):
        logging.debug('Message to delete not found')
        return True

    if isinstance(exception, MessageTextIsEmpty):
        logging.debug('MessageTextIsEmpty')
        return True

    if isinstance(exception, Unauthorized):
        logging.info(f'Unauthorized: {exception}')
        return True

    if isinstance(exception, InvalidQueryID):
        logging.exception(f'InvalidQueryID: {exception} \nUpdate: {update}')
        return True

    if isinstance(exception, TelegramAPIError):
        logging.exception(f'TelegramAPIError: {exception} \nUpdate: {update}')
        return True
    if isinstance(exception, RetryAfter):
        logging.exception(f'RetryAfter: {exception} \nUpdate: {update}')
        return True
    if isinstance(exception, CantParseEntities):
        logging.exception(f'CantParseEntities: {exception} \nUpdate: {update}')
        return True
    
    logging.exception(f'Update: {update} \n{exception}')
</file>

<file path="handlers/groups/__init__.py">
from .group_panel import dp

__all__ = ["dp"]
</file>

<file path="handlers/groups/group_panel.py">
from aiogram import types
from aiogram.dispatcher.filters import BoundFilter, IDFilter

from data.config import ADMINS
from filters import IsGroup
from loader import dp


@dp.message_handler(IsGroup(), IDFilter(ADMINS), commands=["panel"])
async def menu(message: types.Message):
    await message.answer("Group panel")
</file>

<file path="handlers/users/__init__.py">
from .panel import dp
from .start import dp
from .contact import dp
from .pay_bill import dp
from .lang_change import dp
from .time_pay import dp
from .echo import dp


__all__ = ["dp"]
</file>

<file path="handlers/users/client_contact.py">
from aiogram import types
from aiogram.dispatcher import FSMContext
from aiogram.dispatcher.filters import Command
from aiogram.dispatcher.filters.state import StatesGroup, State

from data.config import ADMINS
from keyboards.default.buttons import return_button
from loader import dp, db
from middlewares import _, __


class Contract(StatesGroup):
    get_id = State()
    text = State()




@dp.message_handler(Command('contact'))
async def get_id(message: types.Message, state: FSMContext):
    await db.message(message.from_user.full_name, message.from_user.id, message.text, message.date)
    if message.from_user.id == 390616685 or message.from_user.id == 133347159:
        client_id = await db.choose_contract()
        msg = await message.answer(text=_("–û–±–µ—Ä—ñ—Ç—å –∫–ª—ñ—î–Ω—Ç–∞, –Ω–∞–ø–∏—Å–∞–≤ –π–æ–≥–æ telegram_id\n"
                                          "{}").format(client_id))
        await db.message("BOT", 10001, msg.html_text, msg.date)
        await Contract.get_id.set()
    else:
        msg = await message.answer(_("–≠—Ç—É –∫–æ–º–∞–Ω–¥—É –º–æ–≥—É—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —Ç–æ–ª—å–∫–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—ã"),
                                   reply_markup=return_button)
        await db.message("BOT", 10001, msg.html_text, msg.date)


@dp.message_handler(state=Contract.get_id)
async def text(message: types.Message, state: FSMContext):
    await db.message(message.from_user.full_name, message.from_user.id, message.text, message.date)
    await state.update_data(telegram_id=message.text)
    msg = await message.answer(_("–¢–µ–ø–µ—Ä –Ω–∞–ø–∏—à—ñ—Ç—å –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è –¥–ª—è –∫–ª—ñ—î–Ω—Ç–∞"))
    await db.message("BOT", 10001, msg.html_text, msg.date)
    await Contract.text.set()


@dp.message_handler(state=Contract.text)
async def client(message: types.Message, state: FSMContext):
    await db.message(message.from_user.full_name, message.from_user.id, message.text, message.date)
    data = await state.get_data()
    telegram_id = await data.get("telegram_id")
    msg = await dp.bot.send_message(state.get_data(telegram_id), message.text)
    await db.message("BOT", 10001, msg.html_text, msg.date)
    await state.reset_state()
    msg1 = await message.answer("–ü–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è –≤—ñ–¥–ø—Ä–∞–≤–ª–µ–Ω–æ", reply_markup=return_button)
    await db.message("BOT", 10001, msg1.html_text, msg.date)
</file>

<file path="handlers/users/contact.py">
from aiogram import types
from aiogram.dispatcher import FSMContext
from aiogram.dispatcher.filters import Command
from aiogram.dispatcher.filters.state import StatesGroup, State

from keyboards.default.buttons import return_button
from loader import dp, db
from middlewares import _


class Contract(StatesGroup):
    get_id = State()
    text = State()


@dp.message_handler(Command('contact'))
async def get_id(message: types.Message, state: FSMContext):
    await db.message(message.from_user.full_name, message.from_user.id, message.text, message.date)
    if message.from_user.id == 390616685 or message.from_user.id == 133347159:
        client_id = await db.choose_contract()
        msg = await message.answer(text=_("–û–±–µ—Ä—ñ—Ç—å –∫–ª—ñ—î–Ω—Ç–∞, –Ω–∞–ø–∏—Å–∞–≤ –π–æ–≥–æ telegram_id\n"))
        await Contract.get_id.set()
        # for i in client_id:
        #     await message.answer(f"–Ü–º—è: {i[0]}\n"
        #                          f"–¢–µ–ª–µ–≥—Ä–∞–º –∞–π–¥—ñ: {i[1]}\n"
        #                          f"–ö–æ–Ω—Ç—Ä–∞–∫—Ç: {i[2]}")
        await db.message("BOT", 10001, msg.html_text, msg.date)
    else:
        msg = await message.answer(_("–≠—Ç—É –∫–æ–º–∞–Ω–¥—É –º–æ–≥—É—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —Ç–æ–ª—å–∫–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—ã"),
                                   reply_markup=return_button)
        await db.message("BOT", 10001, msg.html_text, msg.date)


@dp.message_handler(state=Contract.get_id)
async def text(message: types.Message, state: FSMContext):
    await db.message(message.from_user.full_name, message.from_user.id, message.text, message.date)
    await state.update_data(telegram_id=message.text)
    msg = await message.answer(_("–¢–µ–ø–µ—Ä –Ω–∞–ø–∏—à—ñ—Ç—å –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è –¥–ª—è –∫–ª—ñ—î–Ω—Ç–∞"))
    await db.message("BOT", 10001, msg.html_text, msg.date)
    await Contract.text.set()


@dp.message_handler(state=Contract.text)
async def contact(message: types.Message, state: FSMContext):
    await db.message(message.from_user.full_name, message.from_user.id, message.text, message.date)
    data = await state.get_data()
    try:
        msg = await dp.bot.send_message(data.get("telegram_id"), message.text)
        await db.message("BOT", 10001, msg.html_text, msg.date)
        await state.reset_state()
        msg1 = await message.answer("–ü–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è –≤—ñ–¥–ø—Ä–∞–≤–ª–µ–Ω–æ", reply_markup=return_button)
        await db.message("BOT", 10001, msg1.html_text, msg.date)
    except Exception as e:
        msg = await message.answer(_("–ü–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è –Ω–µ –±—É–ª–æ –¥–æ—Å—Ç–∞–≤–ª–µ–Ω–µ, —Å–∫–æ—Ä—ñ—à –∑–∞ –≤—Å–µ telegram id –Ω–µ –ø—Ä–∞–≤–∏–ª—å–Ω–∏–π"),
                                   reply_markup=return_button)
        await db.message("BOT", 10001, msg.html_text, msg.date)
        await state.reset_state()
</file>

<file path="handlers/users/echo.py">
import logging

from aiogram import types
from aiogram.dispatcher import FSMContext
from aiogram.dispatcher.filters import Command
from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton

from data.config import ADMINS
from keyboards.default.buttons import return_button, tel_button, client_request, unknown_request_button
from loader import dp, db
from utils.db_api.database import tel_by_group, account_show

from middlewares import _, __

from utils.db_api import database


@dp.message_handler(Command('phone'))
async def phones_message(message: types.Message, state: FSMContext):
    phones = await tel_by_group()
    await message.answer(phones, reply_markup=return_button)


@dp.message_handler(content_types=types.ContentTypes.ANY, state=None)
@dp.message_handler(Command(['help']))
async def bot_echo(message: types.Message):
    await db.message(message.from_user.full_name, message.from_user.id, message.text, message.date)
    tel = await db.select_tel(message.from_user.id)
    ban = await db.get_ban()

    print(ban)
    if await db.is_alarm(message.from_user.id):
        await database.search_query(tel)
        if len(database.data) > 0:
            message_alarm = await db.get_alarm_message(int(database.data[6]))
            await message.answer(message_alarm, reply_markup=return_button)
    elif message.from_user.id in ban:
        await message.answer(
            _("–í—ñ—Ç–∞—î–º–æ! –î–ª—è –∑–≤–µ—Ä–Ω–µ–Ω–Ω—è, –±—É–¥—å-–ª–∞—Å–∫–∞, —Å–∫–æ—Ä–∏—Å—Ç–∞–π—Ç–µ—Å—å –Ω–∞—à–∏–º email —Ç–µ—Ö–Ω—ñ—á–Ω–æ—ó –ø—ñ–¥—Ç—Ä–∏–º–∫–∏ support@infoaura.com.ua"))
    elif tel:
        await database.search_query(tel)
        if len(database.data) > 0:
            msg = await message.answer(text=_("–í–∞—à username: {}\n"
                                              "–ù–∞ –≤–∞—à–æ–º—É —Ä–∞—Ö—É–Ω–∫—É: {}\n"
                                              "–í–∞—à –Ω–æ–º–µ—Ä –¥–æ–≥–æ–≤–æ—Ä—É: {}\n"
                                              "–í–∞—à–µ –ü–Ü–ë: {}\n"
                                              "–°—Ç–∞–Ω –ø–æ—Å–ª—É–≥–∏: {}\n"
                                              "–í–∞—à –ø–∞–∫–µ—Ç: {}").format(
                database.data[0], database.data[1], database.data[2], database.data[3], database.data[4],
                database.data[5]),
                reply_markup=client_request)
            await db.message("BOT", 10001, msg.html_text, msg.date)
            # for admin in ADMINS:
            #     msg = await dp.bot.send_message(admin, text=_("–ù–æ–≤–µ –∑–∞–ø–∏—Ç–∞–Ω–Ω—è –∑ –ø–æ—Å–ª—É–≥–∏ –∫–ª—ñ—î–Ω—Ç–∞\n")
        else:
            msg = await message.answer(
                text=_("–í–∫–∞–∑–∞–Ω–∏–π –Ω–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω—É –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–æ —É –Ω–∞—à–æ–º—É –±—ñ–ª—ñ–Ω–≥—É\n"
                       "–Ø–∫—â–æ –≤–∏ –±–∞–∂–∞—î—Ç–µ –ø—ñ–¥–∫–ª—é—á–∏—Ç–∏—Å—è - –∑–∞–ª–∏—à—Ç–µ –∑–∞—è–≤–∫—É –Ω–∞ –ø—ñ–¥–∫–ª—é—á–µ–Ω–Ω—è –Ω–∞—Ç–∏—Å–Ω—É–≤—à–∏ –∫–Ω–æ–ø–∫—É"),
                reply_markup=unknown_request_button)
            await db.message("BOT", 10001, msg.html_text, msg.date)
        try:
            for admin in ADMINS:
                answer_reply = InlineKeyboardMarkup()
                answer_reply.add(InlineKeyboardButton(text="–í—ñ–¥–ø–æ–≤—ñ—Å—Ç–∏",
                                                      callback_data=f"answer {message.from_user.id}"))
                if message.content_type == 'text':
                    msg = await dp.bot.send_message(chat_id=admin,
                                                    text=f"–°–æ–æ–±—â–µ–Ω–∏—è –æ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è: {message.from_user.full_name}\n"
                                                         f"–¢–µ–∫—Å—Ç —Å–æ–æ–±—â–µ–Ω–∏—è: {message.text}\n"
                                                         f"–¢–µ–ª–µ—Ñ–æ–Ω: {await db.select_tel(message.from_user.id)}\n"
                                                         f"–ù–æ–º–µ—Ä –¥–æ–≥–æ–≤–æ—Ä—É: {database.data[2]}\n",
                                                    parse_mode='HTML',
                                                    reply_markup=answer_reply)
                    await db.message("BOT", 10001, msg.html_text, msg.date)
                elif message.content_type == 'photo':
                    msg = await dp.bot.send_photo(chat_id=admin,
                                                  photo=message.photo[-1].file_id,
                                                  caption=f"–°–æ–æ–±—â–µ–Ω–∏—è –æ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è: {message.from_user.full_name}\n"
                                                          f"–¢–µ–∫—Å—Ç —Å–æ–æ–±—â–µ–Ω–∏—è: {message.caption}\n"
                                                          f"–¢–µ–ª–µ—Ñ–æ–Ω: {await db.select_tel(message.from_user.id)}\n"
                                                          f"–ù–æ–º–µ—Ä –¥–æ–≥–æ–≤–æ—Ä—É: {database.data[2]}\n",
                                                  parse_mode='HTML',
                                                  reply_markup=answer_reply)
                    await db.message("BOT", 10001, msg.html_text, msg.date)
                elif message.content_type == 'document':
                    msg = await dp.bot.send_document(chat_id=admin,
                                                     document=message.document.file_id,
                                                     caption=f"–°–æ–æ–±—â–µ–Ω–∏—è –æ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è:"
                                                             f" {message.from_user.full_name}\n"
                                                             f"–¢–µ–ª–µ—Ñ–æ–Ω: {await db.select_tel(message.from_user.id)}\n"
                                                             f"–ù–æ–º–µ—Ä –¥–æ–≥–æ–≤–æ—Ä—É: {database.data[2]}\n",
                                                     parse_mode='HTML',
                                                     reply_markup=answer_reply)
                    await db.message("BOT", 10001, msg.html_text, msg.date)
                elif message.content_type == 'video':
                    msg = await dp.bot.send_video(chat_id=admin,
                                                  video=message.video.file_id,
                                                  caption=f"–°–æ–æ–±—â–µ–Ω–∏—è –æ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è:"
                                                          f" {message.from_user.full_name}\n"
                                                          f"–¢–µ–ª–µ—Ñ–æ–Ω: {await db.select_tel(message.from_user.id)}\n"
                                                          f"–ù–æ–º–µ—Ä –¥–æ–≥–æ–≤–æ—Ä—É: {database.data[2]}\n",
                                                  parse_mode='HTML',
                                                  reply_markup=answer_reply)
                    await db.message("BOT", 10001, msg.html_text, msg.date)
        except Exception as err:
            logging.exception(err)
    else:
        await database.search_query(tel)
        if len(database.data) > 0:
            msg = await message.answer(text=_("–í–∞—à username: {}\n"
                                              "–ù–∞ –≤–∞—à–æ–º—É —Ä–∞—Ö—É–Ω–∫—É: {}\n"
                                              "–í–∞—à –Ω–æ–º–µ—Ä –¥–æ–≥–æ–≤–æ—Ä—É: {}\n"
                                              "–í–∞—à–µ –ü–Ü–ë: {}\n"
                                              "–°—Ç–∞–Ω –ø–æ—Å–ª—É–≥–∏: {}\n"
                                              "–í–∞—à –ø–∞–∫–µ—Ç: {}").format(
                database.data[0], database.data[1], database.data[2], database.data[3], database.data[4],
                database.data[5]),
                reply_markup=client_request)
            await db.message("BOT", 10001, msg.html_text, msg.date)
        else:
            msg = await message.answer(
                text=_("–í–∫–∞–∑–∞–Ω–∏–π –Ω–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω—É –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–æ —É –Ω–∞—à–æ–º—É –±—ñ–ª—ñ–Ω–≥—É\n"
                       "–Ø–∫—â–æ –≤–∏ –±–∞–∂–∞—î—Ç–µ –ø—ñ–¥–∫–ª—é—á–∏—Ç–∏—Å—è - –∑–∞–ª–∏—à—Ç–µ –∑–∞—è–≤–∫—É –Ω–∞ –ø—ñ–¥–∫–ª—é—á–µ–Ω–Ω—è –Ω–∞—Ç–∏—Å–Ω—É–≤—à–∏ –∫–Ω–æ–ø–∫—É"),
                reply_markup=unknown_request_button)
            await db.message("BOT", 10001, msg.html_text, msg.date)
        try:
            for admin in ADMINS:
                answer_reply = InlineKeyboardMarkup()
                answer_reply.add(InlineKeyboardButton(text="–í—ñ–¥–ø–æ–≤—ñ—Å—Ç–∏",
                                                      callback_data=f"answer {message.from_user.id}"))
                if message.content_type == 'text':
                    msg = await dp.bot.send_message(chat_id=admin,
                                                    text=f"–°–æ–æ–±—â–µ–Ω–∏—è –æ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è: {message.from_user.full_name}\n"
                                                         f"–¢–µ–∫—Å—Ç —Å–æ–æ–±—â–µ–Ω–∏—è: {message.text}\n"
                                                         f"–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –±–µ–∑ —Ç–µ–ª–µ—Ñ–æ–Ω–∞",
                                                    parse_mode='HTML',
                                                    reply_markup=answer_reply)
                    await db.message("BOT", 10001, msg.html_text, msg.date)
                elif message.content_type == 'photo':
                    msg = await dp.bot.send_photo(chat_id=admin,
                                                  photo=message.photo[-1].file_id,
                                                  caption=f"–°–æ–æ–±—â–µ–Ω–∏—è –æ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è: {message.from_user.full_name}\n"
                                                          f"–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –±–µ–∑ —Ç–µ–ª–µ—Ñ–æ–Ω–∞",
                                                  parse_mode='HTML',
                                                  reply_markup=answer_reply)
                    await db.message("BOT", 10001, msg.html_text, msg.date)
                elif message.content_type == 'document':
                    msg = await dp.bot.send_document(chat_id=admin,
                                                     document=message.document.file_id,
                                                     caption=f"–°–æ–æ–±—â–µ–Ω–∏—è –æ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è:"
                                                             f" {message.from_user.full_name}\n"
                                                             f"–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –±–µ–∑ —Ç–µ–ª–µ—Ñ–æ–Ω–∞",
                                                     reply_markup=answer_reply)
                    await db.message("BOT", 10001, msg.html_text, msg.date)
                elif message.content_type == 'video':
                    msg = await dp.bot.send_video(chat_id=admin,
                                                  video=message.video.file_id,
                                                  caption=f"–°–æ–æ–±—â–µ–Ω–∏—è –æ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è:"
                                                          f" {message.from_user.full_name}\n"

                                                          f"–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –±–µ–∑ —Ç–µ–ª–µ—Ñ–æ–Ω–∞",
                                                  parse_mode='HTML',
                                                  reply_markup=answer_reply)
                    await db.message("BOT", 10001, msg.html_text, msg.date)
        except Exception as err:
            logging.exception(err)

# –≠—Ö–æ —Ö–µ–Ω–¥–ª–µ—Ä, –∫—É–¥–∞ –ª–µ—Ç—è—Ç –í–°–ï —Å–æ–æ–±—â–µ–Ω–∏—è —Å —É–∫–∞–∑–∞–Ω–Ω—ã–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ–º
# @dp.message_handler(state="*", content_types=types.ContentTypes.ANY)
# async def bot_echo_all(message: types.Message, state: FSMContext):
#     await db.message(message.from_user.full_name, message.from_user.id, message.text, message.date)
#     state = await state.get_state()
#     await message.answer(f"–≠—Ö–æ –≤ —Å–æ—Å—Ç–æ—è–Ω–∏–∏ <code>{state}</code>.\n"
#                          f"\n–°–æ–¥–µ—Ä–∂–∞–Ω–∏–µ —Å–æ–æ–±—â–µ–Ω–∏—è:\n"
#                          f"<code>{message}</code>")
</file>

<file path="handlers/users/lang_change.py">
from loader import dp, db

from aiogram.dispatcher.filters.builtin import Text
from aiogram import types
from aiogram.types import ReplyKeyboardMarkup, KeyboardButton

from middlewares import _, __
from keyboards.default.buttons import lang_change


@dp.message_handler(Text(equals=__("–ó–º—ñ–Ω–∏—Ç–∏ –º–æ–≤—É")))
async def change_lang(message: types.Message):
    await db.message(message.from_user.full_name, message.from_user.id, message.text, message.date)
    ban = await db.get_ban()
    if message.from_user.id in ban:
        await message.answer(
            _("–í—ñ—Ç–∞—î–º–æ! –î–ª—è –∑–≤–µ—Ä–Ω–µ–Ω–Ω—è, –±—É–¥—å-–ª–∞—Å–∫–∞, —Å–∫–æ—Ä–∏—Å—Ç–∞–π—Ç–µ—Å—å –Ω–∞—à–∏–º email —Ç–µ—Ö–Ω—ñ—á–Ω–æ—ó –ø—ñ–¥—Ç—Ä–∏–º–∫–∏ support@infoaura.com.ua"))
    else:
        msg = await message.answer(text=_("–û–±–µ—Ä—ñ—Ç—å –º–æ–≤—É"), reply_markup=lang_change)
        await db.message("BOT", 10001, msg.html_text, msg.date)


@dp.message_handler(Text(equals=["üá∑üá∫ RU", "üá∫üá∏ EN", "üá∫üá¶ UA"]))
async def changed_lang(message: types.Message):
    await db.message(message.from_user.full_name, message.from_user.id, message.text, message.date)
    await db.set_lang(message.text[3:].lower(), message.from_user.id)
    if message.text[3:] == "UA":
        return_button = ReplyKeyboardMarkup(resize_keyboard=True, keyboard=[
            [
                KeyboardButton(text="–ì–æ–ª–æ–≤–Ω–µ –º–µ–Ω—é")
            ]
        ], one_time_keyboard=True)
    elif message.text[3:] == "EN":
        return_button = ReplyKeyboardMarkup(resize_keyboard=True, keyboard=[
            [
                KeyboardButton(text="Main menu")
            ]
        ], one_time_keyboard=True)
    else:
        return_button = ReplyKeyboardMarkup(resize_keyboard=True, keyboard=[
            [
                KeyboardButton(text="–ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é")
            ]
        ], one_time_keyboard=True)

    msg = await message.answer(
        text=_("–í–∏ –æ–±—Ä–∞–ª–∏ {}\n–¢–µ–ø–µ—Ä –º–æ–∂–µ—Ç–µ –ø–µ—Ä–µ–π—Ç–∏ —É –≥–æ–ª–æ–≤–Ω–µ –º–µ–Ω—é",
               locale=message.text[3:].lower()).format(message.text[3:]),
        reply_markup=return_button)
    await db.message("BOT", 10001, msg.html_text, msg.date)
</file>

<file path="handlers/users/notify_balance.py">
import datetime

from data import config
from loader import scheduler
from aiogram import Dispatcher
from loader import db
from utils.db_api import database
from middlewares import _


async def notify_clients(dp: Dispatcher):
    client_id = await db.contract()
    for i in client_id:
        telegram_id = i[0]
        contract = i[1]
        today = datetime.date.today()
        today = today.replace(day=12)
        today = today.strftime("%d.%m.%y")
        balance = await database.balance(contract)
        if balance is False:
            pass
        else:
            await dp.bot.send_message(telegram_id,
                                      _("–®–∞–Ω–æ–≤–Ω–∏–π –∫–ª—ñ—î–Ω—Ç! –î–æ—Å—Ç—É–ø –¥–æ —ñ–Ω—Ç–µ—Ä–Ω–µ—Ç—É –∑–∞ —Ä–∞—Ö—É–Ω–∫–æ–º {} –±—É–¥–µ –∑–∞–±–ª–æ–∫–æ–≤–∞–Ω–∏–π "
                                        "{}"
                                        "–†–µ–∫–æ–º–µ–Ω–¥—É—î–º–æ –ø–æ–ø–æ–≤–Ω–∏—Ç–∏ –±–∞–ª–∞–Ω—Å –º—ñ–Ω—ñ–º—É–º –Ω–∞ {}").format(contract, today, balance))


def scheduler_jobs():
    scheduler.add_job(notify_clients, "cron", day="9", hour="23", minute="45")
</file>

<file path="handlers/users/panel.py">
import re

import aiohttp
import transliterate
from aiogram import types
from aiogram.dispatcher import FSMContext
from aiogram.dispatcher.filters import IDFilter, Text
from aiogram.types import ReplyKeyboardRemove, InlineKeyboardMarkup, InlineKeyboardButton

from data.config import ADMINS
from keyboards.default.admin import admin_keyboard, accept_message, back, accept_sms, accept_message_phone, \
    admin_account_menu, search_choice, back_inline, grp_choice, redact_alarm
from loader import dp, db
from utils.db_api.database import pay_balance, t_pay, users_with_alarm
from utils.format_number import unformat_number, number, format_text_account_admin
from utils.misc.find_in_bill import find
from utils.misc.sms_message import send_message_sms


@dp.message_handler(IDFilter(ADMINS), commands=['stats'], state='*')
async def stats(message: types.Message):
    await db.message(message.from_user.full_name, message.from_user.id, message.text, message.date)
    await message.answer("–ö—ñ–ª—å–∫—ñ—Å—Ç—å –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á—ñ–≤: " + str(await db.count_users()) + "\n" +
                         "–ö—ñ–ª—å–∫—ñ—Å—Ç—å –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á—ñ–≤ —Å –¥–æ–≥–æ–≤–æ—Ä–æ–º: " + str(await db.count_contract_users()),
                         reply_markup=back)


@dp.message_handler(IDFilter(ADMINS), text="–ù–∞–∑–∞–¥", state='*')
@dp.message_handler(IDFilter(ADMINS))
async def admin_panel(message: types.Message, state: FSMContext):
    await db.message(message.from_user.full_name, message.from_user.id, message.text, message.date)
    await state.finish()
    result = await find(contract=message.text)
    if result:
        if type(result) is dict:
            await message.answer(text=await format_text_account_admin(result), reply_markup=admin_account_menu)
            await state.set_data({"account": result['contract']})
        else:
            msg = await message.answer("–ö–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞ –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–æ\n"
                                       "–ü–∞–Ω–µ–ª—å –∞–¥–º—ñ–Ω—ñ—Å—Ç—Ä–∞—Ç–æ—Ä–∞", reply_markup=admin_keyboard)
            await db.message(message.from_user.full_name, message.from_user.id, msg.html_text, msg.date)
    else:
        msg = await message.answer("–ü–∞–Ω–µ–ª—å –∞–¥–º—ñ–Ω—ñ—Å—Ç—Ä–∞—Ç–æ—Ä–∞", reply_markup=admin_keyboard)
        await db.message(message.from_user.full_name, message.from_user.id, msg.html_text, msg.date)


@dp.callback_query_handler(IDFilter(ADMINS), text="back", state='*')
async def admin_panel(call: types.CallbackQuery, state: FSMContext):
    await call.answer()
    await db.message(call.from_user.full_name, call.from_user.id, call.message.text, call.message.date)
    await state.finish()
    msg = await call.message.answer("–ü–∞–Ω–µ–ª—å –∞–¥–º—ñ–Ω—ñ—Å—Ç—Ä–∞—Ç–æ—Ä–∞", reply_markup=admin_keyboard)
    await db.message(call.from_user.full_name, call.from_user.id, msg.html_text, msg.date)


@dp.callback_query_handler(IDFilter(ADMINS), Text(startswith='answer'), state='*')
async def admin_answer(call: types.CallbackQuery, state: FSMContext):
    await state.finish()
    user_id = call.data.split(' ')[1]
    print(user_id)
    await state.set_state('answer')
    await state.set_data({'user_id': user_id})
    await db.message(call.from_user.full_name, call.from_user.id, call.message.text, call.message.date)
    await call.message.answer(f"–ù–∞–ø–∏—à—ñ—Ç—å —Ç–µ–∫—Å—Ç –∞–±–æ –Ω–∞–¥—ñ—à–ª—ñ—Ç—å —Ñ–æ—Ç–æ/–¥–æ–∫—É–º–µ–Ω—Ç/–≤—ñ–¥–µ–æ"
                              f" –¥–ª—è –≤—ñ–¥–ø—Ä–∞–≤–ª–µ–Ω–Ω—è –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á—É {user_id}", reply_markup=back)


@dp.callback_query_handler(IDFilter(ADMINS), state='*', text='message_history')
async def message_history_start(call: types.CallbackQuery, state: FSMContext):
    await call.answer()
    await db.message(call.from_user.full_name, call.from_user.id, call.message.text, call.message.date)
    msg = await call.message.answer(text='–ù–∞–ø–∏—à—ñ—Ç—å –∫—ñ–ª—å–∫—ñ—Å—Ç—å –æ—Å—Ç–∞–Ω–Ω—ñ—Ö –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω—å —â–æ –±–∞–∂–∞—î—Ç–µ –ø–µ—Ä–µ–¥–∏–≤–∏—Ç–∏—Å—è\n'
                                         '–°—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–∞ –∫—ñ–ª—å–∫—ñ—Å—Ç—å 10 –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω—å')
    await db.message("BOT", 10001, msg.html_text, msg.date)
    await state.set_state('message_history')


@dp.message_handler(IDFilter(ADMINS), state='answer', content_types=['text', 'photo', 'document', 'video'])
async def admin_answer_text(message: types.Message, state: FSMContext):
    user_id = await state.get_data()
    print(user_id)
    await state.finish()
    if message.content_type == "text":
        await dp.bot.send_message(user_id['user_id'], message.text)
        for admin in ADMINS:
            msg = await dp.bot.send_message(admin,
                                            "–ü–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è:\n" + message.text + "\n–î–æ:\n" + str(user_id['user_id']),
                                            reply_markup=back)
            await db.message(message.from_user.full_name, message.from_user.id, msg.html_text, msg.date)
    elif message.content_type == "photo":
        await dp.bot.send_photo(user_id['user_id'], message.photo[-1].file_id)
        for admin in ADMINS:
            msg = await dp.bot.send_photo(admin, message.photo[-1].file_id, caption="–î–æ:\n" + str(user_id['user_id']),
                                          reply_markup=back)
            await db.message(message.from_user.full_name, message.from_user.id, msg.html_text, msg.date)
    elif message.content_type == "document":
        await dp.bot.send_document(user_id['user_id'], message.document.file_id)
        for admin in ADMINS:
            msg = await dp.bot.send_document(admin, message.document.file_id, caption="–î–æ:\n" + str(user_id['user_id']),
                                             reply_markup=back)
            await db.message(message.from_user.full_name, message.from_user.id, msg.html_text, msg.date)
    elif message.content_type == "video":
        await dp.bot.send_video(user_id['user_id'], message.video.file_id)
        for admin in ADMINS:
            msg = await dp.bot.send_video(admin, message.video.file_id, caption="–î–æ:\n" + str(user_id['user_id']),
                                          reply_markup=back)
            await db.message(message.from_user.full_name, message.from_user.id, msg.html_text, msg.date)


@dp.callback_query_handler(IDFilter(ADMINS), text="admin_change_balance", state='*')
async def admin_change_balance(call: types.CallbackQuery, state: FSMContext):
    await call.answer()
    await db.message(call.from_user.full_name, call.from_user.id, call.message.text, call.message.date)
    msg = await call.message.answer("–í–≤–µ–¥—ñ—Ç—å —Å—É–º–º—É –Ω–∞ —è–∫—É —Ö–æ—á–µ—Ç–µ –∑–º—ñ–Ω–∏—Ç–∏ –±–∞–ª–∞–Ω—Å\n"
                                    "–ë–∞–ª–∞–Ω—Å –±—É–¥–µ –¥–æ—Ä—ñ–≤–Ω—é–≤–∞—Ç–∏ x + —Å—É–º–º–∞ –∫–æ—Ç—Ä—É –≤–∫–∞–∂–µ—Ç–µ, –¥–µ —Ö –ø–æ—Ç–æ—á–Ω–∏–π –±–∞–ª–∞–Ω—Å",
                                    reply_markup=back)
    await state.set_state('admin_change_balance')
    await db.message("BOT", 10001, msg.html_text, msg.date)


@dp.callback_query_handler(IDFilter(ADMINS), text="account_menu")
async def account_menu(call: types.CallbackQuery, state: FSMContext):
    await call.answer()
    await db.message(call.from_user.full_name, call.from_user.id, call.message.text, call.message.date)
    msg = await call.message.answer("–í–∏–±–µ—Ä—ñ—Ç—å —è–∫ –±—É–¥–µ–º–æ —à—É–∫–∞—Ç–∏ –∞–±–æ–Ω–µ–Ω—Ç–∞", reply_markup=search_choice)
    await state.set_state('account_menu')
    await db.message("BOT", 10001, msg.html_text, msg.date)


@dp.callback_query_handler(IDFilter(ADMINS), text=['search_contract', 'search_phone', 'search_name', 'search_address'],
                           state='account_menu')
async def search_account(call: types.CallbackQuery, state: FSMContext):
    await call.answer()
    if call.data == 'search_contract':
        await state.set_state('search_contract')
        await db.message(call.from_user.full_name, call.from_user.id, call.message.text, call.message.date)
        msg = await call.message.answer("–í–≤–µ–¥—ñ—Ç—å –Ω–æ–º–µ—Ä –¥–æ–≥–æ–≤–æ—Ä—É")
        await db.message("BOT", 10001, msg.html_text, msg.date)
    elif call.data == 'search_phone':
        await state.set_state('search_phone')
        await db.message(call.from_user.full_name, call.from_user.id, call.message.text, call.message.date)
        msg = await call.message.answer("–í–≤–µ–¥—ñ—Ç—å –Ω–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω—É")
        await db.message("BOT", 10001, msg.html_text, msg.date)
    elif call.data == 'search_name':
        await state.set_state('search_name')
        await db.message(call.from_user.full_name, call.from_user.id, call.message.text, call.message.date)
        msg = await call.message.answer("–í–≤–µ–¥—ñ—Ç—å —ñ–º'—è —Ç–∞/–∞–±–æ –ø—Ä—ñ–∑–≤–∏—â–µ")
        await db.message("BOT", 10001, msg.html_text, msg.date)
    elif call.data == 'search_address':
        await state.set_state('search_address')
        await db.message(call.from_user.full_name, call.from_user.id, call.message.text, call.message.date)
        msg = await call.message.answer("–í–≤–µ–¥—ñ—Ç—å –≤—É–ª–∏—Ü—é, –±—É–¥–∏–Ω–æ–∫ —Ç–∞ –∫–≤–∞—Ä—Ç–∏—Ä—É —á–µ—Ä–µ–∑ –ø—Ä–æ–±—ñ–ª")
        await db.message("BOT", 10001, msg.html_text, msg.date)


@dp.message_handler(IDFilter(ADMINS), state=["search_contract", "search_phone", "search_name", "search_address"])
async def account_menu_handler(message: types.Message, state: FSMContext):
    await db.message(message.from_user.full_name, message.from_user.id, message.text, message.date)
    await state.set_data({"account": message.text})
    try:
        cur_state = await state.get_state()
        if cur_state == 'search_contract':
            result = await find(contract=message.text)
        elif cur_state == 'search_phone':
            result = await find(phone=message.text)
        elif cur_state == 'search_name':
            result = await find(name=message.text)
        elif cur_state == 'search_address':
            result = await find(address=message.text.split(' '))

        if type(result) is dict:
            await message.answer(text=await format_text_account_admin(result), reply_markup=admin_account_menu)
            await state.set_data({"account": result['contract']})
        elif type(result) is list and len(result) > 0:
            await state.set_state('account_menu_list')
            keyboard = types.InlineKeyboardMarkup(row_width=1)
            for i in result:
                keyboard.add(
                    types.InlineKeyboardButton(text=i['contract'] + " " + i['fio'],
                                               callback_data='account_menu_list' + i['contract']))
                await state.set_data({i['contract']: i})
            await message.answer(text="–í–∏–±–µ—Ä—ñ—Ç—å –¥–æ–≥–æ–≤—ñ—Ä", reply_markup=keyboard)
        else:
            await message.answer(text=f"–ù–µ –≤–¥–∞–ª–æ—Å—è –∑–Ω–∞–π—Ç–∏ –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞",
                                 reply_markup=back)
    except Exception as e:
        print(e)
        await message.answer(text=f"–ù–µ –≤–¥–∞–ª–æ—Å—è –∑–Ω–∞–π—Ç–∏ –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞ –∑ –Ω–æ–º–µ—Ä–æ–º –¥–æ–≥–æ–≤–æ—Ä—É {message.text}", reply_markup=back)
        await state.finish()


@dp.callback_query_handler(IDFilter(ADMINS), state='account_menu_list')
async def account_menu_list(call: types.CallbackQuery, state: FSMContext):
    await call.answer()
    await db.message(call.from_user.full_name, call.from_user.id, call.message.text, call.message.date)
    await state.set_state('account_menu')
    result = await find(contract=call.data[17:])
    msg = await call.message.answer(text=await format_text_account_admin(result), reply_markup=admin_account_menu)
    await state.set_data({"account": result['contract']})
    await db.message("BOT", 10001, msg.html_text, msg.date)


@dp.message_handler(IDFilter(ADMINS), state='message_history')
async def message_history_get(message: types.Message, state: FSMContext):
    await db.message(message.from_user.full_name, message.from_user.id, message.text, message.date)
    contract = await state.get_data()
    user_id = await db.select_user_id_by_contract(contract['account'])
    messages = await db.get_message_history(user_id=user_id[0][0], message_count=int(message.text))
    msg = await message.answer(f'–û—Å—Ç–∞–Ω–Ω—ñ {message.text} –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω—å –≤—ñ–¥ {contract["account"]}')
    print(messages)
    for i in messages:
        if i[0] is not None:
            msg1 = await message.answer(i[0])
            await db.message("BOT", 10001, msg1.html_text, msg1.date)
        else:
            msg2 = await message.answer('–ü—É—Å—Ç–µ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è (–Ω–∞—Ç–∏—Å–∫–∞–Ω–Ω—è –Ω–∞ –∫–Ω–æ–ø–∫—É –∞–±–æ –≤—ñ–¥–ø—Ä–∞–≤–∫–∞ —Ñ–∞–π–ª—ñ–≤)')
            await db.message("BOT", 10001, msg2.html_text, msg2.date)
    await db.message("BOT", 10001, msg.html_text, msg.date)
    msg3 = await message.answer('–ó–∞–∫—ñ–Ω—á–µ–Ω–Ω—è –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω—å', reply_markup=back)
    await db.message("BOT", 10001, msg3.html_text, msg3.date)
    await state.finish()



@dp.callback_query_handler(IDFilter(ADMINS), text='admin_temporary_payment', state='*')
async def admin_temporary_payment(call: types.CallbackQuery, state: FSMContext):
    await call.answer()
    await db.message(call.from_user.full_name, call.from_user.id, call.message.text, call.message.date)
    try:
        account = await state.get_data()
        account = account['account']
        if await t_pay(account):
            msg = await call.message.answer(text="–¢–∏–º—á–∞—Å–æ–≤–∏–π –ø–ª–∞—Ç—ñ–∂ —É–≤—ñ–º–∫–Ω–µ–Ω–∏–π —É—Å–ø—ñ—à–Ω–æ –¥–ª—è –∞–±–æ–Ω–µ–Ω—Ç–∞ " + account)
        else:
            msg = await call.message.answer(text="–¢–∏–º—á–∞—Å–æ–≤–∏–π –ø–ª–∞—Ç—ñ–∂ –Ω–µ –≤–¥–∞–ª–æ—Å—è –≤–≤—ñ–º–∫–Ω—É—Ç–∏ –¥–ª—è –∞–±–æ–Ω–µ–Ω—Ç–∞ " + account)
    except KeyError:
        contract = re.search(r'\b\d{8}\b', call.message.text)
        if await t_pay(contract[0]):
            msg = await call.message.answer(text="–¢–∏–º—á–∞—Å–æ–≤–∏–π –ø–ª–∞—Ç—ñ–∂ —É–≤—ñ–º–∫–Ω–µ–Ω–∏–π —É—Å–ø—ñ—à–Ω–æ –¥–ª—è –∞–±–æ–Ω–µ–Ω—Ç–∞ " + contract[0])
        else:
            msg = await call.message.answer(text="–¢–∏–º—á–∞—Å–æ–≤–∏–π –ø–ª–∞—Ç—ñ–∂ –Ω–µ –≤–¥–∞–ª–æ—Å—è –≤–≤—ñ–º–∫–Ω—É—Ç–∏ –¥–ª—è –∞–±–æ–Ω–µ–Ω—Ç–∞ " + contract[0])
    result = await find(contract=call.data[17:])
    msg1 = await call.message.answer(text=await format_text_account_admin(result), reply_markup=admin_account_menu)
    await state.set_data({"account": result['contract']})

    await db.message("BOT", 10001, msg.html_text, msg.date)
    await db.message("BOT", 10001, msg1.html_text, msg1.date)


@dp.message_handler(IDFilter(ADMINS), state="admin_change_balance")
async def admin_change_balance_handler(message: types.Message, state: FSMContext):
    await db.message(message.from_user.full_name, message.from_user.id, message.text, message.date)
    account = await state.get_data()
    account = account['account']
    print(account)
    try:
        await pay_balance(account, message.text)
        msg = await message.answer(text=f"–ë–∞–ª–∞–Ω—Å –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞ {account} –ø–æ–ø–æ–≤–Ω–µ–Ω–æ –Ω–∞ {message.text}", reply_markup=back)
        result = await find(contract=account)
        balance = result['balance']
        phone = result['telefon']
        if len(phone) > 13:
            phone = phone[:13]
            print(phone)
        print(phone)
        try:
            text = "–†–∞—Ö—É–Ω–æ–∫ " + account + " –ø–æ–ø–æ–≤–Ω–µ–Ω–∏–π –Ω–∞ " + message.text + " –ù–∞ —Ä–∞—Ö—É–Ω–∫—É –∑–Ω–∞—Ö–æ–¥–∏—Ç—å—Å—è " + str(balance)
            await send_message_sms(unformat_number(phone), text)
        except Exception as e:
            print(e)
        await state.finish()
    except Exception as e:
        print(e)
        msg = await message.answer(text=f"–ù–µ –≤–¥–∞–ª–æ—Å—è –ø–æ–ø–æ–≤–Ω–∏—Ç–∏ –±–∞–ª–∞–Ω—Å –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞ {account} –Ω–∞ {message.text}",
                                   reply_markup=back)
        await state.finish()
    await db.message("BOT", 10001, msg.html_text, msg.date)


# Send via telegram or sms to user
@dp.callback_query_handler(IDFilter(ADMINS), lambda call: call.data == "panel_send_message")
async def send_message(call: types.CallbackQuery, state: FSMContext):
    await db.message(call.from_user.full_name, call.from_user.id, call.message.text, call.message.date)
    text = "–ù–∞–ø–∏—à—ñ—Ç—å –º–æ–±—ñ–ª—å–Ω–∏–π —Ç–µ–ª–µ—Ñ–æ–Ω –∞–±–æ —Ç–µ–ª–µ–≥—Ä–∞–º —ñ–¥ –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞"
    await call.answer()
    msg = await dp.bot.send_message(call.from_user.id, text, reply_markup=ReplyKeyboardRemove())
    await db.message(call.from_user.full_name, call.from_user.id, text, msg.date)
    await state.set_state("send_message_phone")


@dp.message_handler(IDFilter(ADMINS), state="send_message_phone")
async def message_get_phone(message: types.Message, state: FSMContext):
    await db.message(message.from_user.full_name, message.from_user.id, message.text, message.date)
    await state.update_data(phone=message.text)
    users = await db.select_all_users()
    users_phones = []
    users_id = []
    try:
        for i in range(len(users)):
            users_phones.append(unformat_number(str(users[i]['phone_number'])))
            users_id.append(users[i]['telegram_id'])
        if message.text in users_id:
            msg = await message.answer('–Ü–î –∑–Ω–∞–π–¥–µ–Ω–∏–π —É –±–æ—Ç—ñ')
            await db.message(message.from_user.full_name, message.from_user.id, msg.html_text, msg.date)
        elif message.text in users_phones:
            msg = await message.answer('–¢–µ–ª–µ—Ñ–æ–Ω –∑–Ω–∞–π–¥–µ–Ω–∏–π —É –±–æ—Ç—ñ')
            await db.message(message.from_user.full_name, message.from_user.id, msg.html_text, msg.date)
        else:
            msg = await message.answer("–¢–µ–ª–µ—Ñ–æ–Ω –∞–±–æ –Ü–î –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–∏–π —É –±–æ—Ç—ñ")
            await db.message(message.from_user.full_name, message.from_user.id, msg.html_text, msg.date)
    except Exception as e:
        print(e)
        msg = await message.answer("–¢–µ–ª–µ—Ñ–æ–Ω –∞–±–æ –Ü–î –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–∏–π —É –±–æ—Ç—ñ\n"
                                   f"–í–∏–Ω–∏–∫–ª–∞ –ø–æ–º–∏–ª–∫–∞ –ø—Ä–∏ –ø–æ—à—É–∫—É {e}")
        await db.message(message.from_user.full_name, message.from_user.id, msg.html_text, msg.date)
    msg = await message.answer("–ù–∞–ø–∏—à—ñ—Ç—å —Ç–µ–∫—Å—Ç –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è, –∞–±–æ –≤—ñ–¥–ø—Ä–∞–≤—Ç–µ —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ—ñ—é/–¥–æ–∫—É–º–µ–Ω—Ç",
                               reply_markup=ReplyKeyboardRemove())
    await db.message(message.from_user.full_name, message.from_user.id, msg.html_text, msg.date)
    await state.set_state("send_message_text")


@dp.message_handler(IDFilter(ADMINS), state="send_message_text", content_types=['text', 'photo', 'document', 'video'])
async def message_get_text(message: types.Message, state: FSMContext):
    await db.message(message.from_user.full_name, message.from_user.id, message.text, message.date)
    if message.content_type == "text":
        await state.update_data(type='text')
        await state.update_data(text=message.text)
    elif message.content_type == "photo":
        await state.update_data(type='photo')
        await state.update_data(photo=message.photo[-1].file_id)
    elif message.content_type == "document":
        await state.update_data(type='document')
        await state.update_data(document=message.document.file_id)
    elif message.content_type == "video":
        await state.update_data(type='video')
        await state.update_data(video=message.video.file_id)
    data = await state.get_data()
    print(data["phone"])
    users = await db.select_all_users()
    users_phones = []
    users_id = []
    try:
        for i in range(len(users)):
            users_phones.append(unformat_number(str(users[i]['phone_number'])))
            users_id.append(users[i]['telegram_id'])
        if int(data['phone']) in users_id:
            msg = await message.answer('–Ü–î –∑–Ω–∞–π–¥–µ–Ω–∏–π —É –±–æ—Ç—ñ, –≤—ñ–¥–ø—Ä–∞–≤–ª—è—Ç–∏?', reply_markup=accept_message)
            await db.message(message.from_user.full_name, message.from_user.id, msg.html_text, msg.date)
        elif data['phone'] in users_phones:
            msg = await message.answer('–¢–µ–ª–µ—Ñ–æ–Ω –∑–Ω–∞–π–¥–µ–Ω–∏–π —É –±–æ—Ç—ñ, –≤—ñ–¥–ø—Ä–∞–≤–ª—è—Ç–∏?', reply_markup=accept_message_phone)
            await db.message(message.from_user.full_name, message.from_user.id, msg.html_text, msg.date)
        else:
            msg = await message.answer("–¢–µ–ª–µ—Ñ–æ–Ω –∞–±–æ –Ü–î –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–∏–π —É –±–æ—Ç—ñ, –≤—ñ–¥–ø—Ä–∞–≤–∏—Ç–∏ —Å–º—Å?",
                                       reply_markup=accept_sms)
            await db.message(message.from_user.full_name, message.from_user.id, msg.html_text, msg.date)
    except Exception as e:
        print(e)
        await state.update_data(phone=unformat_number(data['phone']))
        data = await state.get_data()
        print(data["phone"])
        for i in range(len(users)):
            users_phones.append(unformat_number(str(users[i]['phone_number'])))
            users_id.append(users[i]['telegram_id'])
        if int(data['phone']) in users_id:
            msg = await message.answer('–Ü–î –∑–Ω–∞–π–¥–µ–Ω–∏–π —É –±–æ—Ç—ñ, –≤—ñ–¥–ø—Ä–∞–≤–ª—è—Ç–∏?', reply_markup=accept_message)
            await db.message(message.from_user.full_name, message.from_user.id, msg.html_text, msg.date)
        elif data['phone'] in users_phones:
            msg = await message.answer('–¢–µ–ª–µ—Ñ–æ–Ω –∑–Ω–∞–π–¥–µ–Ω–∏–π —É –±–æ—Ç—ñ, –≤—ñ–¥–ø—Ä–∞–≤–ª—è—Ç–∏?', reply_markup=accept_message_phone)
            await db.message(message.from_user.full_name, message.from_user.id, msg.html_text, msg.date)
        else:
            msg = await message.answer("–¢–µ–ª–µ—Ñ–æ–Ω –∞–±–æ –Ü–î –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–∏–π —É –±–æ—Ç—ñ, –≤—ñ–¥–ø—Ä–∞–≤–∏—Ç–∏ —Å–º—Å?",
                                       reply_markup=accept_sms)
            await db.message(message.from_user.full_name, message.from_user.id, msg.html_text, msg.date)


@dp.callback_query_handler(IDFilter(ADMINS),
                           lambda call: call.data == "panel_send_message_decline", state="send_message_text")
@dp.callback_query_handler(IDFilter(ADMINS),
                           lambda call: call.data == "panel_send_message_accept", state="send_message_text")
async def message_send_accept(call: types.CallbackQuery, state: FSMContext):
    await db.message(call.from_user.full_name, call.from_user.id, call.message.text, call.message.date)
    data = await state.get_data()
    telegram_id = data['phone']
    contract = await db.select_contract(int(telegram_id))
    contract = contract[0]['contract']
    print(telegram_id)
    await call.answer()
    type = data['type']
    if type == 'text':
        text = data['text']
        if call.data == "panel_send_message_accept":
            try:
                msg_u = await dp.bot.send_message(chat_id=int(telegram_id), text=text, parse_mode="HTML")
                await db.message("BOT", 10001, msg_u.html_text, msg_u.date)
                for admin in ADMINS:
                    msg = await dp.bot.send_message(admin,
                                                    f"–ü–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è –≤—ñ–¥–ø—Ä–∞–≤–ª–µ–Ω–æ –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á—É: {telegram_id}"
                                                    f"\n–¢–µ–∫—Å—Ç –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è: {text}"
                                                    f"\n–ö–æ–Ω—Ç—Ä–∞–∫—Ç –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞: {contract}",
                                                    reply_markup=back)
                    await db.message("BOT", 10001, msg.html_text, msg.date)
                await state.finish()
            except Exception as e:
                msg = await dp.bot.send_message(call.from_user.id, f"–ü–æ–º–∏–ª–∫–∞ –≤—ñ–¥–ø—Ä–∞–≤–ª–µ–Ω–Ω—è –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è: {e}",
                                                reply_markup=back)
                await db.message("BOT", 10001, msg.html_text, msg.date)
                await state.finish()
        elif call.data == "panel_send_message_decline":
            msg = await dp.bot.send_message(call.from_user.id, "–ü–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è –Ω–µ –≤—ñ–¥–ø—Ä–∞–≤–ª–µ–Ω–æ", reply_markup=back)
            await db.message("BOT", 10001, msg.html_text, msg.date)
            await state.finish()
    elif type == 'photo':
        photo = data['photo']
        if call.data == "panel_send_message_accept":
            try:
                msg_u = await dp.bot.send_photo(chat_id=int(telegram_id), photo=photo)
                await db.message("BOT", 10001, msg_u.photo[-1].file_id, msg_u.date)
                for admin in ADMINS:
                    msg = await dp.bot.send_message(admin,
                                                    f"–ü–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è –≤—ñ–¥–ø—Ä–∞–≤–ª–µ–Ω–æ –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á—É: {telegram_id}"
                                                    f"\n–ö–æ–Ω—Ç—Ä–∞–∫—Ç –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞: {contract}")
                    photo_send = await dp.bot.send_photo(admin, photo=photo, caption="–§–æ—Ç–æ –≤—ñ–¥–ø—Ä–∞–≤–ª–µ–Ω–æ",
                                                         reply_markup=back)
                    await db.message("BOT", 10001, msg.html_text, msg.date)
                    await db.message("BOT", 10001, photo_send.photo[-1].file_id, photo_send.date)
                await state.finish()
            except Exception as e:
                msg = await dp.bot.send_message(call.from_user.id, f"–ü–æ–º–∏–ª–∫–∞ –≤—ñ–¥–ø—Ä–∞–≤–ª–µ–Ω–Ω—è –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è: {e}",
                                                reply_markup=back)
                await db.message("BOT", 10001, msg.html_text, msg.date)
                await state.finish()
        elif call.data == "panel_send_message_decline":
            msg = await dp.bot.send_message(call.from_user.id, "–ü–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è –Ω–µ –≤—ñ–¥–ø—Ä–∞–≤–ª–µ–Ω–æ", reply_markup=back)
            await db.message("BOT", 10001, msg.html_text, msg.date)
            await state.finish()
    elif type == 'document':
        document = data['document']
        if call.data == "panel_send_message_accept":
            try:
                msg_u = await dp.bot.send_document(chat_id=int(telegram_id), document=document)
                await db.message("BOT", 10001, msg_u.document.file_id, msg_u.date)
                for admin in ADMINS:
                    msg = await dp.bot.send_message(admin,
                                                    f"–ü–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è –≤—ñ–¥–ø—Ä–∞–≤–ª–µ–Ω–æ –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á—É: {telegram_id}"
                                                    f"\n–ö–æ–Ω—Ç—Ä–∞–∫—Ç –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞: {contract}")
                    doc_send = await dp.bot.send_document(admin, document=document, caption="–î–æ–∫—É–º–µ–Ω—Ç –≤—ñ–¥–ø—Ä–∞–≤–ª–µ–Ω–æ",
                                                          reply_markup=back)
                    await db.message("BOT", 10001, msg.html_text, msg.date)
                    await db.message("BOT", 10001, doc_send.document.file_id, doc_send.date)
                await state.finish()
            except Exception as e:
                msg = await dp.bot.send_message(call.from_user.id, f"–ü–æ–º–∏–ª–∫–∞ –≤—ñ–¥–ø—Ä–∞–≤–ª–µ–Ω–Ω—è –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è: {e}",
                                                reply_markup=back)
                await db.message("BOT", 10001, msg.html_text, msg.date)
                await state.finish()
        elif call.data == "panel_send_message_decline":
            msg = await dp.bot.send_message(call.from_user.id, "–ü–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è –Ω–µ –≤—ñ–¥–ø—Ä–∞–≤–ª–µ–Ω–æ", reply_markup=back)
            await db.message("BOT", 10001, msg.html_text, msg.date)
            await state.finish()
    elif type == 'video':
        video = data['video']
        if call.data == "panel_send_message_accept":
            try:
                msg_u = await dp.bot.send_video(chat_id=int(telegram_id), video=video)
                await db.message("BOT", 10001, msg_u.video.file_id, msg_u.date)
                for admin in ADMINS:
                    msg = await dp.bot.send_message(admin,
                                                    f"–ü–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è –≤—ñ–¥–ø—Ä–∞–≤–ª–µ–Ω–æ –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á—É: {telegram_id}"
                                                    f"\n–ö–æ–Ω—Ç—Ä–∞–∫—Ç –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞: {contract}")
                    video_send = await dp.bot.send_video(admin, video=video, caption="–í—ñ–¥–µ–æ –≤—ñ–¥–ø—Ä–∞–≤–ª–µ–Ω–æ",
                                                         reply_markup=back)
                    await db.message("BOT", 10001, msg.html_text, msg.date)
                    await db.message("BOT", 10001, video_send.video.file_id, video_send.date)
                await state.finish()
            except Exception as e:
                msg = await dp.bot.send_message(call.from_user.id, f"–ü–æ–º–∏–ª–∫–∞ –≤—ñ–¥–ø—Ä–∞–≤–ª–µ–Ω–Ω—è –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è: {e}",
                                                reply_markup=back)
                await db.message("BOT", 10001, msg.html_text, msg.date)
                await state.finish()
        elif call.data == "panel_send_message_decline":
            msg = await dp.bot.send_message(call.from_user.id, "–ü–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è –Ω–µ –≤—ñ–¥–ø—Ä–∞–≤–ª–µ–Ω–æ", reply_markup=back)
            await db.message("BOT", 10001, msg.html_text, msg.date)
            await state.finish()


@dp.callback_query_handler(IDFilter(ADMINS),
                           lambda call: call.data == "panel_send_message_decline_phone", state="send_message_text")
@dp.callback_query_handler(IDFilter(ADMINS),
                           lambda call: call.data == "panel_send_message_accept_phone", state="send_message_text")
async def message_send_accept_phone(call: types.CallbackQuery, state: FSMContext):
    await call.answer()
    await db.message(call.from_user.full_name, call.from_user.id, call.message.text, call.message.date)
    phone = await state.get_data()
    phone = phone['phone']
    telegram_id = await db.select_id_by_phone(number(phone))
    telegram_id = telegram_id[0]['telegram_id']
    data = await state.get_data()
    contract = await db.select_contract(telegram_id)
    contract = contract[0]['contract']
    type = data['type']
    if type == 'text':
        text = data['text']
        if call.data == "panel_send_message_accept_phone":
            try:
                msg_u = await dp.bot.send_message(chat_id=int(telegram_id), text=text, parse_mode="HTML")
                await db.message("BOT", 10001, msg_u.html_text, msg_u.date)
                for admin in ADMINS:
                    msg = await dp.bot.send_message(admin,
                                                    f"–ü–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è –≤—ñ–¥–ø—Ä–∞–≤–ª–µ–Ω–æ –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á—É: {telegram_id}"
                                                    f"\n–¢–µ–∫—Å—Ç –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è: {text}"
                                                    f"\n–ö–æ–Ω—Ç—Ä–∞–∫—Ç –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞: {contract}",
                                                    reply_markup=back)
                    await db.message("BOT", 10001, msg.html_text, msg.date)
                await state.finish()
            except Exception as e:
                msg = await dp.bot.send_message(call.from_user.id, f"–ü–æ–º–∏–ª–∫–∞ –≤—ñ–¥–ø—Ä–∞–≤–ª–µ–Ω–Ω—è –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è: {e}",
                                                reply_markup=back)
                await db.message("BOT", 10001, msg.html_text, msg.date)
                await state.finish()
        elif call.data == "panel_send_message_decline_phone":
            msg = await dp.bot.send_message(call.from_user.id, "–ü–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è –Ω–µ –≤—ñ–¥–ø—Ä–∞–≤–ª–µ–Ω–æ", reply_markup=back)
            await db.message("BOT", 10001, msg.html_text, msg.date)
            await state.finish()
    elif type == 'photo':
        photo = data['photo']
        if call.data == "panel_send_message_accept_phone":
            try:
                msg_u = await dp.bot.send_photo(chat_id=int(telegram_id), photo=photo)
                await db.message("BOT", 10001, msg_u.photo[-1].file_id, msg_u.date)
                for admin in ADMINS:
                    msg = await dp.bot.send_message(admin,
                                                    f"–ü–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è –≤—ñ–¥–ø—Ä–∞–≤–ª–µ–Ω–æ –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á—É: {telegram_id}"
                                                    f"\n–ö–æ–Ω—Ç—Ä–∞–∫—Ç –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞: {contract}")
                    photo_send = await dp.bot.send_photo(admin, photo=photo, caption="–§–æ—Ç–æ –≤—ñ–¥–ø—Ä–∞–≤–ª–µ–Ω–æ",
                                                         reply_markup=back)
                    await db.message("BOT", 10001, msg.html_text, msg.date)
                    await db.message("BOT", 10001, photo_send.photo[-1].file_id, photo_send.date)
                await state.finish()
            except Exception as e:
                msg = await dp.bot.send_message(call.from_user.id, f"–ü–æ–º–∏–ª–∫–∞ –≤—ñ–¥–ø—Ä–∞–≤–ª–µ–Ω–Ω—è –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è: {e}",
                                                reply_markup=back)
                await db.message("BOT", 10001, msg.html_text, msg.date)
                await state.finish()
        elif call.data == "panel_send_message_decline_phone":
            msg = await dp.bot.send_message(call.from_user.id, "–ü–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è –Ω–µ –≤—ñ–¥–ø—Ä–∞–≤–ª–µ–Ω–æ", reply_markup=back)
            await db.message("BOT", 10001, msg.html_text, msg.date)
            await state.finish()
    elif type == 'document':
        document = data['document']
        if call.data == "panel_send_message_accept_phone":
            try:
                msg_u = await dp.bot.send_document(chat_id=int(telegram_id), document=document)
                await db.message("BOT", 10001, msg_u.document.file_id, msg_u.date)
                for admin in ADMINS:
                    msg = await dp.bot.send_message(admin,
                                                    f"–ü–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è –≤—ñ–¥–ø—Ä–∞–≤–ª–µ–Ω–æ –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á—É: {telegram_id}"
                                                    f"\n–ö–æ–Ω—Ç—Ä–∞–∫—Ç –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞: {contract}")
                    doc_send = await dp.bot.send_document(admin, document=document, caption="–î–æ–∫—É–º–µ–Ω—Ç –≤—ñ–¥–ø—Ä–∞–≤–ª–µ–Ω–æ",
                                                          reply_markup=back)
                    await db.message("BOT", 10001, msg.html_text, msg.date)
                    await db.message("BOT", 10001, doc_send.document.file_id, doc_send.date)
                await state.finish()
            except Exception as e:
                msg = await dp.bot.send_message(call.from_user.id, f"–ü–æ–º–∏–ª–∫–∞ –≤—ñ–¥–ø—Ä–∞–≤–ª–µ–Ω–Ω—è –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è: {e}",
                                                reply_markup=back)
                await db.message("BOT", 10001, msg.html_text, msg.date)
                await state.finish()
        elif call.data == "panel_send_message_decline_phone":
            msg = await dp.bot.send_message(call.from_user.id, "–ü–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è –Ω–µ –≤—ñ–¥–ø—Ä–∞–≤–ª–µ–Ω–æ", reply_markup=back)
            await db.message("BOT", 10001, msg.html_text, msg.date)
            await state.finish()
    elif type == 'video':
        video = data['video']
        if call.data == "panel_send_message_accept_phone":
            try:
                msg_u = await dp.bot.send_video(chat_id=int(telegram_id), video=video)
                await db.message("BOT", 10001, msg_u.video.file_id, msg_u.date)
                for admin in ADMINS:
                    msg = await dp.bot.send_message(admin,
                                                    f"–ü–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è –≤—ñ–¥–ø—Ä–∞–≤–ª–µ–Ω–æ –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á—É: {telegram_id}"
                                                    f"\n–ö–æ–Ω—Ç—Ä–∞–∫—Ç –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞: {contract}")
                    video_send = await dp.bot.send_video(admin, video=video, caption="–í—ñ–¥–µ–æ –≤—ñ–¥–ø—Ä–∞–≤–ª–µ–Ω–æ",
                                                         reply_markup=back)
                    await db.message("BOT", 10001, msg.html_text, msg.date)
                    await db.message("BOT", 10001, video_send.video.file_id, video_send.date)
                await state.finish()
            except Exception as e:
                msg = await dp.bot.send_message(call.from_user.id, f"–ü–æ–º–∏–ª–∫–∞ –≤—ñ–¥–ø—Ä–∞–≤–ª–µ–Ω–Ω—è –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è: {e}",
                                                reply_markup=back)
                await db.message("BOT", 10001, msg.html_text, msg.date)
                await state.finish()
        elif call.data == "panel_send_message_decline_phone":
            msg = await dp.bot.send_message(call.from_user.id, "–ü–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è –Ω–µ –≤—ñ–¥–ø—Ä–∞–≤–ª–µ–Ω–æ", reply_markup=back)
            await db.message("BOT", 10001, msg.html_text, msg.date)
            await state.finish()


@dp.callback_query_handler(IDFilter(ADMINS),
                           lambda call: call.data == "panel_send_sms_decline", state="send_message_text")
@dp.callback_query_handler(IDFilter(ADMINS),
                           lambda call: call.data == "panel_send_sms_accept", state="send_message_text")
async def message_send_accept_sms(call: types.CallbackQuery, state: FSMContext):
    await db.message(call.from_user.full_name, call.from_user.id, call.message.text, call.message.date)
    phone = await state.get_data()
    phone = phone['phone']
    data = await state.get_data()
    if data['type'] == 'text':
        text = data['text']
        await call.answer()
        if call.data == "panel_send_sms_accept":
            try:
                msg = await dp.bot.send_message(call.from_user.id, "–ü–æ—á–∏–Ω–∞—é –≤—ñ–¥–ø—Ä–∞–≤–∫—É SMS...")
                await db.message("BOT", 10001, msg.html_text, msg.date)
                if len(text) >= 53:
                    print('transliterate')
                    email_text_t = transliterate.translit(text, 'uk', reversed=True)
                    text = f"{email_text_t}\nt.me/infoaura_bot"
                else:
                    print("no transliterate")
                    text = f"{text}\nt.me/infoaura_bot"
                async with aiohttp.ClientSession() as session:
                    print("Sending sms to:", phone,
                          "with text:", text,
                          "length of string:", len(text))
                    param = {'version': 'http',
                             'login': '380936425274',
                             "password": "iw79izvy",
                             'key': '6cf938587e0ed0d992566730169e82e229f097c7',
                             'command': "send",
                             'from': 'IAura',
                             'to': f"{phone}",
                             'message': f'{text}'}
                    async with session.request('http', "https://smsukraine.com.ua/api/http.php",
                                               params=param) as sms:
                        print("SMS: ", await sms.text())
                for admin in ADMINS:
                    msg_1 = await dp.bot.send_message(admin,
                                                      f"SMS –≤—ñ–¥–ø—Ä–∞–≤–ª–µ–Ω–æ"
                                                      f"\n–¢–µ–ª–µ—Ñ–æ–Ω: {phone}"
                                                      f"\n–¢–µ–∫—Å—Ç: {text}",
                                                      reply_markup=back)
                    await db.message("BOT", 10001, msg_1.html_text, msg_1.date)
                await state.finish()
            except Exception as e:
                msg = await dp.bot.send_message(call.from_user.id, f"–ü–æ–º–∏–ª–∫–∞ –≤—ñ–¥–ø—Ä–∞–≤–ª–µ–Ω–Ω—è SMS: {e}",
                                                reply_markup=back)
                await db.message("BOT", 10001, msg.html_text, msg.date)
                await state.finish()
        elif call.data == "panel_send_sms_decline":
            msg = await dp.bot.send_message(call.from_user.id, "SMS –Ω–µ –≤—ñ–¥–ø—Ä–∞–≤–ª–µ–Ω–æ", reply_markup=back)
            await db.message("BOT", 10001, msg.html_text, msg.date)
            await state.finish()
    else:
        await call.answer()
        msg = await dp.bot.send_message(call.from_user.id, "SMS –Ω–µ –≤—ñ–¥–ø—Ä–∞–≤–ª–µ–Ω–æ, —Ç—ñ–ª—å–∫–∏ —Ç–µ–∫—Å—Ç–æ–≤—ñ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è",
                                        reply_markup=back)
        await db.message("BOT", 10001, msg.html_text, msg.date)
        await state.finish()


@dp.callback_query_handler(IDFilter(ADMINS), text='ban_account')
async def ban_account(call: types.CallbackQuery, state: FSMContext):
    await db.message(call.from_user.full_name, call.from_user.id, call.message.text, call.message.date)
    await call.answer()
    await call.message.edit_text("–í–≤–µ–¥—ñ—Ç—å Telegram ID –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞, —è–∫–æ–≥–æ –ø–æ—Ç—Ä—ñ–±–Ω–æ –∑–∞–±–ª–æ–∫—É–≤–∞—Ç–∏",
                                 reply_markup=back_inline)
    await state.set_state("ban_account")


@dp.message_handler(IDFilter(ADMINS), state="ban_account")
async def ban_id(message: types.Message, state: FSMContext):
    await db.message(message.from_user.full_name, message.from_user.id, message.text, message.date)
    try:
        await db.set_ban(message.text)
        await message.answer(f"–ö–æ—Ä–∏—Å—Ç—É–≤–∞—á –∑ Telegram ID: {message.text} –∑–∞–±–ª–æ–∫–æ–≤–∞–Ω–∏–π",
                             reply_markup=back)
    except Exception as e:
        await message.answer(f"–ü–æ–º–∏–ª–∫–∞: {e}", reply_markup=back)
    await state.finish()


@dp.callback_query_handler(IDFilter(ADMINS), text='unban_account')
async def unban_account(call: types.CallbackQuery, state: FSMContext):
    await db.message(call.from_user.full_name, call.from_user.id, call.message.text, call.message.date)
    await call.answer()
    banned_id = await db.get_ban()
    if banned_id:
        await call.message.edit_text("–í–≤–µ–¥—ñ—Ç—å Telegram ID –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞, —è–∫–æ–≥–æ –ø–æ—Ç—Ä—ñ–±–Ω–æ —Ä–æ–∑–±–ª–æ–∫—É–≤–∞—Ç–∏"
                                     "{} - {}".format(*banned_id),
                                     reply_markup=back_inline)
        await state.set_state("unban_account")
    else:
        await call.message.edit_text("–í–≤–µ–¥—ñ—Ç—å Telegram ID –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞, —è–∫–æ–≥–æ –ø–æ—Ç—Ä—ñ–±–Ω–æ —Ä–æ–∑–±–ª–æ–∫—É–≤–∞—Ç–∏",
                                     reply_markup=back_inline)
        await state.set_state('unban_account')


@dp.message_handler(IDFilter(ADMINS), state="unban_account")
async def unban_id(message: types.Message, state: FSMContext):
    await db.message(message.from_user.full_name, message.from_user.id, message.text, message.date)
    try:
        await db.set_unban(message.text)
        await message.answer(f"–ö–æ—Ä–∏—Å—Ç—É–≤–∞—á –∑ Telegram ID: {message.text} —Ä–æ–∑–±–ª–æ–∫–æ–≤–∞–Ω–∏–π",
                             reply_markup=back)
    except Exception as e:
        await message.answer(f"–ü–æ–º–∏–ª–∫–∞: {e}", reply_markup=back)
    await state.finish()


@dp.callback_query_handler(IDFilter(ADMINS), text='register_alarm')
async def register_alarm(call: types.CallbackQuery, state: FSMContext):
    await db.message(call.from_user.full_name, call.from_user.id, call.message.text, call.message.date)
    await call.answer()
    await call.message.answer("–í–∏–±–µ—Ä—ñ—Ç—å –≥—Ä—É–ø–ø—É –∞–≤–∞—Ä—ñ—ó, –∞–±–æ –≤–≤–µ–¥—ñ—Ç—å –Ω–æ–º–µ—Ä–∏ –¥–æ–≥–æ–≤—Ä—É –∫–æ—Ç—Ä–∏—Ö —Å—Ç–æ—Å—É—î—Ç—å—Å—è –∞–≤–∞—Ä—ñ—è.\n"
                              "–ù–∞–ø—Ä–∏–∫–ª–∞–¥:\n"
                              "10000001, 10000002, 10000003..", reply_markup=grp_choice)

    await state.set_state("register_alarm")


@dp.message_handler(IDFilter(ADMINS), state="register_alarm")
async def message_alarm_by_contract(message: types.Message, state: FSMContext):
    await db.message(message.from_user.full_name, message.from_user.id, message.text, message.date)
    try:
        alarm_message = "–ó–∞ –í–∞—à–∏–º –ø—ñ–¥–∫–ª—é—á–µ–Ω–Ω—è–º –∑–∞—Ä–µ—î—Å—Ç—Ä–æ–≤–∞–Ω–∞ –∞–≤–∞—Ä—ñ–π–Ω–∞ —Å–∏—Ç—É–∞—Ü—ñ—è. –ü–µ—Ä–µ–≤—ñ—Ä—Ç–µ —Ç–µ—Ä–º—ñ–Ω —É—Å—É–Ω–µ–Ω–Ω—è –∞–≤–∞—Ä—ñ—ó –ø—ñ–∑–Ω—ñ—à–µ."
        await db.insert_alarm(alarm_message, message.text)
        print(message.text)
        users = message.text.split(",")
        users_count = 0
        for user in users:
            try:
                if await db.set_alarm_for_users(user):
                    users_count += 1
            except Exception as e:
                print(e)
        await message.answer(f"–ó–∞—Ä–µ—î—Å—Ç—Ä–æ–≤–∞–Ω–æ –∞–≤–∞—Ä—ñ—é –¥–ª—è {users_count} –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á—ñ–≤", reply_markup=back)
    except Exception as e:
        await message.answer(f"–ü–æ–º–∏–ª–∫–∞: {e}", reply_markup=back_inline)
        await state.finish()


@dp.callback_query_handler(IDFilter(ADMINS), state="register_alarm")
async def message_alarm_grp(call: types.CallbackQuery, state: FSMContext):
    await db.message(call.from_user.full_name, call.from_user.id, call.message.text, call.message.date)
    await call.answer()
    try:
        alarm_message = "–ó–∞ –í–∞—à–∏–º –ø—ñ–¥–∫–ª—é—á–µ–Ω–Ω—è–º –∑–∞—Ä–µ—î—Å—Ç—Ä–æ–≤–∞–Ω–∞ –∞–≤–∞—Ä—ñ–π–Ω–∞ —Å–∏—Ç—É–∞—Ü—ñ—è. –ü–µ—Ä–µ–≤—ñ—Ä—Ç–µ —Ç–µ—Ä–º—ñ–Ω —É—Å—É–Ω–µ–Ω–Ω—è –∞–≤–∞—Ä—ñ—ó –ø—ñ–∑–Ω—ñ—à–µ."
        await db.insert_alarm(alarm_message, call.data)
        print(call.data)
        users = await users_with_alarm(int(call.data))
        users_count = 0
        for user in users:
            try:
                if await db.set_alarm_for_users(user):
                    users_count += 1
            except Exception as e:
                print(e)
                pass
        await call.message.edit_text(f"–ê–≤–∞—Ä—ñ—é —É—Å–ø—ñ—à–Ω–æ –∑–∞—Ä–µ—î—Å—Ç—Ä–æ–≤–∞–Ω–æ –¥–ª—è {users_count} –∞–±–æ–Ω–µ–Ω—Ç—ñ–≤",
                                     reply_markup=back_inline)
        await state.finish()
    except Exception as e:
        await call.message.edit_text(f"–ü–æ–º–∏–ª–∫–∞: {e}", reply_markup=back_inline)
        await state.finish()


@dp.callback_query_handler(IDFilter(ADMINS), text='redactor_alarm')
async def redactor_alarm(call: types.CallbackQuery, state: FSMContext):
    await db.message(call.from_user.full_name, call.from_user.id, call.message.text, call.message.date)
    await call.answer()
    await call.message.edit_text("–í–∏–±–µ—Ä—ñ—Ç—å –Ω–µ–æ–±—Ö—ñ–¥–Ω—É –¥—ñ—é", reply_markup=redact_alarm)
    await state.set_state("redactor_alarm")


@dp.callback_query_handler(IDFilter(ADMINS), state='redactor_alarm')
async def redacting_alarm_state(call: types.CallbackQuery, state: FSMContext):
    await db.message(call.from_user.full_name, call.from_user.id, call.message.text, call.message.date)
    await call.answer()
    records = await db.get_alarm()
    keyboard_alarms = InlineKeyboardMarkup(row_width=1)
    txt = ''
    print(records)
    if not records:
        await call.message.edit_text("–ê–≤–∞—Ä—ñ–π –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–æ", reply_markup=back_inline)
        await state.finish()
    elif call.data == 'change_message_alarm':
        txt = '–û–±–µ—Ä—ñ—Ç—å –∞–≤–∞—Ä—ñ—é –¥–ª—è —Ä–µ–¥–∞–≥—É–≤–∞–Ω–Ω—è –∑–∞ alarm_id\n'
        await state.set_state("redact_alarm")
    elif call.data == 'delete_alarm':
        txt = '–û–±–µ—Ä—ñ—Ç—å –∞–≤–∞—Ä—ñ—é –¥–ª—è –≤–∏–¥–∞–ª–µ–Ω–Ω—è –∑–∞ alarm_id\n'
        await state.set_state("delete_alarm")
    if records:
        for record in records:
            txt += f"{record[0]} - {record[1]}\n"
            keyboard_alarms.add(InlineKeyboardButton(f"{record[0]}", callback_data=f"{record[0]}"))
        await call.message.edit_text(txt, reply_markup=keyboard_alarms)
    else:
        pass


@dp.callback_query_handler(IDFilter(ADMINS), state='redact_alarm')
async def redacting_alarm(call: types.CallbackQuery, state: FSMContext):
    await db.message(call.from_user.full_name, call.from_user.id, call.message.text, call.message.date)
    try:
        await call.answer()
        await call.message.edit_text("–ù–∞–ø–∏—à—ñ—Ç—å –Ω–æ–≤–µ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è —â–æ —Å—Ç–æ—Å—É—î—Ç—å—Å—è –∞–≤–∞—Ä—ñ—ó",
                                     reply_markup=back_inline)
        await state.set_state("redact_alarm_message")
        await state.update_data(alarm_id=call.data)
    except Exception as e:
        await call.message.edit_text(f"–ü–æ–º–∏–ª–∫–∞: {e}", reply_markup=back_inline)
        await state.finish()


@dp.callback_query_handler(IDFilter(ADMINS), state='delete_alarm')
async def deleting_alarm(call: types.CallbackQuery, state: FSMContext):
    await db.message(call.from_user.full_name, call.from_user.id, call.message.text, call.message.date)
    try:
        await call.answer()
        await db.delete_alarm(call.data)
        await call.message.edit_text(f"–ê–≤–∞—Ä—ñ—é –∑ ID {call.data} —É—Å–ø—ñ—à–Ω–æ –≤–∏–¥–∞–ª–µ–Ω–æ", reply_markup=back_inline)
        await state.finish()
    except Exception as e:
        await call.message.edit_text(f"–ü–æ–º–∏–ª–∫–∞: {e}", reply_markup=back_inline)
        await state.finish()


@dp.message_handler(IDFilter(ADMINS), state="redact_alarm_message")
async def message_alarm_redact(message: types.Message, state: FSMContext):
    await db.message(message.from_user.full_name, message.from_user.id, message.text, message.date)
    alarm_id = await state.get_data()
    await db.change_alarm_message(message.text, int(alarm_id['alarm_id']))
    await message.answer(f"–ê–≤–∞—Ä—ñ—è –∑ id: {alarm_id['alarm_id']}\n–ù–æ–≤–∏–π —Ç–µ–∫—Å—Ç –∞–≤–∞—Ä—ñ—ó:\n{message.text}",
                         reply_markup=back)
    await state.finish()
</file>

<file path="handlers/users/pay_bill.py">
import logging
import random
import re
import uuid

import aiogram.utils.exceptions
from aiogram import types
from aiogram.dispatcher import FSMContext
from aiogram.dispatcher.filters import Text
from aiogram.types import ContentType, LabeledPrice

from data.config import ADMINS
from data.pays_item import P180, P1080, P200, P1200, P350, P2100
from keyboards.default.buttons import return_button
from loader import dp, db, bot
from middlewares import _, __
from utils.db_api import database
from utils.db_api.database import check_contract_exists
from utils.misc.pay_load import Pay


@dp.message_handler(Text(__("–ü–æ–ø–æ–≤–Ω–∏—Ç–∏ —Ä–∞—Ö—É–Ω–æ–∫")), state="*")
async def contract_pay(message: types.Message, state: FSMContext):
    await db.message(message.from_user.full_name, message.from_user.id, message.text, message.date)
    await database.search_query(tel=await db.select_tel(user_id=message.from_user.id))
    ban = await db.get_ban()
    print(ban)
    if message.from_user.id in ban:
        await message.answer(_("–í—ñ—Ç–∞—î–º–æ! –î–ª—è –∑–≤–µ—Ä–Ω–µ–Ω–Ω—è, –±—É–¥—å-–ª–∞—Å–∫–∞, —Å–∫–æ—Ä–∏—Å—Ç–∞–π—Ç–µ—Å—å –Ω–∞—à–∏–º email —Ç–µ—Ö–Ω—ñ—á–Ω–æ—ó –ø—ñ–¥—Ç—Ä–∏–º–∫–∏ "
                               "support@infoaura.com.ua"))
    elif database.data[5] == '–°–¢–ê–ù–î–ê–†–¢(180–≥—Ä–Ω).':
        msg = await message.answer(text=_("–ó–≤–µ—Ä–Ω—ñ—Ç—å —É–≤–∞–≥—É, —â–æ —Ç—É—Ç –≤–∏ –º–æ–∂–µ—Ç–µ –ø–æ–ø–æ–≤–Ω–∏—Ç–∏ —Ç—ñ–ª—å–∫–∏ —Å–≤—ñ–π –æ—Å–æ–±–æ–≤–∏–π —Ä–∞—Ö—É–Ω–æ–∫!"))
        await db.message("BOT", 10001, msg.html_text, msg.date)
        invoice_pay = P180.generate_invoice()
        await state.update_data({'bill_id_p180': invoice_pay[' start_parameter']})
        await bot.send_invoice(message.from_user.id, **invoice_pay, payload=180)
        msg1 = await message.answer(
            text=_("–î—ñ—î –∞–∫—Ü—ñ—è - –ø–æ–ø–æ–≤–Ω–∏ —Ä–∞—Ö—É–Ω–æ–∫ –Ω–∞ 6 –º—ñ—Å—è—Ü—ñ–≤ –æ–¥–Ω–∏–º –ø–ª–∞—Ç–µ–∂–µ–º —Ç–∞ –æ—Ç—Ä–∏–º—É–π 10% –≤—ñ–¥ —Å—É–º–∏ –ø–æ–ø–æ–≤–Ω–µ–Ω–Ω—è!"))
        await db.message("BOT", 10001, msg1.html_text, msg1.date)
        invoice_pay = P1080.generate_invoice()
        await state.update_data({'bill_id_p1080': invoice_pay[' start_parameter']})
        await bot.send_invoice(message.from_user.id, **invoice_pay, payload=1080)
    elif database.data[5] == 'PON-100(200–≥—Ä–Ω)' or database.data[5] == 'VIP WIFI-200':
        msg = await message.answer(text=_("–ó–≤–µ—Ä–Ω—ñ—Ç—å —É–≤–∞–≥—É, —â–æ —Ç—É—Ç –≤–∏ –º–æ–∂–µ—Ç–µ –ø–æ–ø–æ–≤–Ω–∏—Ç–∏ —Ç—ñ–ª—å–∫–∏ —Å–≤—ñ–π –æ—Å–æ–±–æ–≤–∏–π —Ä–∞—Ö—É–Ω–æ–∫!"))
        invoice_pay = P200.generate_invoice()
        await state.update_data({'bill_id_p200': invoice_pay[' start_parameter']})
        await bot.send_invoice(message.from_user.id, **invoice_pay, payload=200)
        await db.message("BOT", 10001, msg.html_text, msg.date)
        msg1 = await message.answer(
            text=_("–î—ñ—î –∞–∫—Ü—ñ—è - –ø–æ–ø–æ–≤–Ω–∏ —Ä–∞—Ö—É–Ω–æ–∫ –Ω–∞ 6 –º—ñ—Å—è—Ü—ñ–≤ –æ–¥–Ω–∏–º –ø–ª–∞—Ç–µ–∂–µ–º —Ç–∞ –æ—Ç—Ä–∏–º—É–π 10% –≤—ñ–¥ —Å—É–º–∏ –ø–æ–ø–æ–≤–Ω–µ–Ω–Ω—è!"))
        invoice_pay = P1200.generate_invoice()
        await state.update_data({'bill_id_p1200': invoice_pay[' start_parameter']})
        await bot.send_invoice(message.from_user.id, **invoice_pay, payload=1200)
        await db.message("BOT", 10001, msg1.html_text, msg1.date)
    elif database.data[5] == 'PON-300(350–≥—Ä–Ω)':
        msg = await message.answer(text=_("–ó–≤–µ—Ä–Ω—ñ—Ç—å —É–≤–∞–≥—É, —â–æ —Ç—É—Ç –≤–∏ –º–æ–∂–µ—Ç–µ –ø–æ–ø–æ–≤–Ω–∏—Ç–∏ —Ç—ñ–ª—å–∫–∏ —Å–≤—ñ–π –æ—Å–æ–±–æ–≤–∏–π —Ä–∞—Ö—É–Ω–æ–∫!"))
        invoice_pay = P350.generate_invoice()
        await state.update_data({'bill_id_p350': invoice_pay[' start_parameter']})
        await bot.send_invoice(message.from_user.id, **invoice_pay, payload=350)
        await db.message("BOT", 10001, msg.html_text, msg.date)
        msg1 = await message.answer(
            text=_("–î—ñ—î –∞–∫—Ü—ñ—è - –ø–æ–ø–æ–≤–Ω–∏ —Ä–∞—Ö—É–Ω–æ–∫ –Ω–∞ 6 –º—ñ—Å—è—Ü—ñ–≤ –æ–¥–Ω–∏–º –ø–ª–∞—Ç–µ–∂–µ–º —Ç–∞ –æ—Ç—Ä–∏–º—É–π 10% –≤—ñ–¥ —Å—É–º–∏ –ø–æ–ø–æ–≤–Ω–µ–Ω–Ω—è!"))
        invoice_pay = P2100.generate_invoice()
        await state.update_data({'bill_id_p2100': invoice_pay[' start_parameter']})
        await bot.send_invoice(message.from_user.id, **invoice_pay, payload=2100)
        await db.message("BOT", 10001, msg1.html_text, msg1.date)
    else:
        msg = await message.answer(text=_("–î–ª—è –ø–æ–ø–æ–≤–Ω–µ–Ω–Ω—è —Ä–∞—Ö—É–Ω–∫—É –≤–≤–µ–¥—ñ—Ç—å —Å—É–º–º—É –ø–æ–ø–æ–≤–Ω–µ–Ω—è!\n"
                                          "–ù–∞–ø—Ä–∏–∫–ª–∞–¥:\n"
                                          "250,\n"
                                          "500\n"),
                                   reply_markup=return_button)
        await state.set_state('invoice_payload')
        await db.message("BOT", 10001, msg.html_text, msg.date)


@dp.message_handler(state='invoice_payload')
async def get_invoice_payload(message: types.Message, state: FSMContext):
    await db.message(message.from_user.full_name, message.from_user.id, message.text, message.date)
    msg = await message.answer(text=_("–í–≤–µ–¥—ñ—Ç—å –Ω–æ–º–µ—Ä –¥–æ–≥–æ–≤–æ—Ä—É —è–∫–∏–π —Ö–æ—á–µ—Ç–µ –ø–æ–ø–æ–≤–Ω–∏—Ç–∏!"))
    await state.set_data({'payload': message.text})
    await state.set_state('invoice_contract')
    await db.message("BOT", 10001, msg.html_text, msg.date)


@dp.message_handler(state='invoice_contract')
@dp.message_handler(state='invalid_payload')
async def get_invoice_contract(message: types.Message, state: FSMContext):
    await db.message(message.from_user.full_name, message.from_user.id, message.text, message.date)
    data = await state.get_data()
    if await state.get_state() == 'invoice_contract':
        data = await state.get_data()
        payload = data['payload']
        amount_pay = int(payload) * 100
        random_id = f"create_invoice_{amount_pay}_{uuid.uuid4()}"
        await state.update_data({'contract': message.text, 'bill_id': random_id})
        contract = message.text
        if re.match(r'^\d{8}$', contract) and await check_contract_exists(contract):
            invoice = Pay(
                title=f"–ü–æ–ø–æ–≤–Ω–µ–Ω–Ω—è –Ω–∞ {payload} –≥—Ä–Ω",
                description=f"–ü–æ–ø–æ–≤–Ω–µ–Ω–Ω—è —Ä–∞—Ö—É–Ω–∫—É {contract} –Ω–∞ {payload} –≥—Ä–∏–≤–µ–Ω—å",
                currency="UAH",
                prices=[
                    LabeledPrice(
                        label=f"–ü–æ–ø–æ–≤–Ω–µ–Ω–Ω—è —Ä–∞—Ö—É–Ω–∫—É {contract}",
                        amount=amount_pay
                    )
                ],
                start_parameter=random_id
            )
            for admin in ADMINS:
                await dp.bot.send_message(admin,
                                          f"–°—Ç–≤–æ—Ä–µ–Ω–æ —ñ–Ω–≤–æ–π—Å –¥–ª—è –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞ {message.from_user.id}:\n"
                                          f"–î–æ–≥–æ–≤—ñ—Ä: {contract}\n"
                                          f"–°—É–º–∞: {payload} –≥—Ä–Ω\n"
                                          f"ID —ñ–Ω–≤–æ–π—Å—É: {random_id}")
            try:
                await bot.send_invoice(message.from_user.id, **invoice.generate_invoice(), payload=str(amount_pay))
            except aiogram.utils.exceptions.CurrencyTotalAmountInvalid:
                msg = await message.answer('–ú—ñ–Ω—ñ–º–∞–ª—å–Ω–∞ —Å—É–º–º–∞ –ø–æ–ø–æ–≤–Ω–µ–Ω–Ω—è –≤—ñ–¥ 0.1$ –≤ –≥—Ä–∏–≤–Ω—è—Ö –∑–∞ –∫—É—Ä—Å–æ–º –ù–ë–£\n'
                                           '–í–≤–µ–¥—ñ—Ç—å —ñ–Ω—à—É —Å—É–º–º—É –ø–æ–ø–æ–≤–Ω–µ–Ω–Ω—è –∞–±–æ –º–æ–∂–µ—Ç–µ –ø–æ–≤–µ—Ä–Ω—É—Ç–∏—Å—è —É –≥–æ–ª–æ–≤–Ω–µ –º–µ–Ω—é',
                                           reply_markup=return_button)
                await db.message("BOT", 10001, msg.html_text, msg.date)
                await state.set_state('invalid_payload')
        else:
            msg = await message.answer('–ù–µ–≤—ñ—Ä–Ω–æ –≤–∫–∞–∑–∞–Ω–∏–π –Ω–æ–º–µ—Ä –¥–æ–≥–æ–≤–æ—Ä—É –¥–ª—è –ø–æ–ø–æ–≤–Ω–µ–Ω–Ω—è\n',
                                       reply_markup=return_button)
            await db.message("BOT", 10001, msg.html_text, msg.date)
    else:
        payload = message.text
        amount_pay = int(payload) * 100
        random_id = f'{data["bill_id"]}'
        contract = f'{data["contract"]}'
        invoice = Pay(
            title=f"–ü–æ–ø–æ–≤–Ω–µ–Ω–Ω—è –Ω–∞ {payload} –≥—Ä–Ω",
            description=f"–ü–æ–ø–æ–≤–Ω–µ–Ω–Ω—è —Ä–∞—Ö—É–Ω–∫—É {contract} –Ω–∞ {payload} –≥—Ä–∏–≤–µ–Ω—å",
            currency="UAH",
            prices=[
                LabeledPrice(
                    label=f"–ü–æ–ø–æ–≤–Ω–µ–Ω–Ω—è —Ä–∞—Ö—É–Ω–∫—É {contract}",
                    amount=amount_pay
                )
            ],
            start_parameter=random_id
        )
        try:
            await bot.send_invoice(message.from_user.id, **invoice.generate_invoice(), payload=str(amount_pay))
        except aiogram.utils.exceptions.CurrencyTotalAmountInvalid:
            msg = await message.answer('–ú—ñ–Ω—ñ–º–∞–ª—å–Ω–∞ —Å—É–º–º–∞ –ø–æ–ø–æ–≤–Ω–µ–Ω–Ω—è –≤—ñ–¥ 0.1$ –≤ –≥—Ä–∏–≤–Ω—è—Ö –∑–∞ –∫—É—Ä—Å–æ–º –ù–ë–£\n'
                                       '–í–≤–µ–¥—ñ—Ç—å —ñ–Ω—à—É —Å—É–º–º—É –ø–æ–ø–æ–≤–Ω–µ–Ω–Ω—è –∞–±–æ –º–æ–∂–µ—Ç–µ –ø–æ–≤–µ—Ä–Ω—É—Ç–∏—Å—è —É –≥–æ–ª–æ–≤–Ω–µ –º–µ–Ω—é',
                                       reply_markup=return_button)
            await db.message("BOT", 10001, msg.html_text, msg.date)
            await state.set_state('invalid_payload')



@dp.pre_checkout_query_handler(state='*')
async def process_pre_checkout(query: types.PreCheckoutQuery):
    await bot.answer_pre_checkout_query(pre_checkout_query_id=query.id,
                                        ok=True)


@dp.message_handler(content_types=ContentType.SUCCESSFUL_PAYMENT, state="*")
async def process_successful_pay(message: types.Message, state: FSMContext):
    await db.message(message.from_user.full_name, message.from_user.id, message.text, message.date)
    data = await state.get_data()
    try:
        if data['contract']:
            data = await state.get_data()
            payload = data['payload']
            contract = data['contract']
            bill_id = data['bill_id']
            await db.add_bill(bill_id, message.from_user.id, message.date, message.from_user.username, contract,
                              payload)
            await database.pay_balance(contract=contract, payload=payload)
            for admin in ADMINS:
                try:
                    msg = await dp.bot.send_message(chat_id=admin,
                                                    text=_("–ö–æ—Ä–∏—Å—Ç—É–≤–∞—á {} —É—Å–ø—ñ—à–Ω–æ –ø–æ–ø–æ–≤–Ω–∏–≤ —Ä–∞—Ö—É–Ω–æ–∫ "
                                                           "–Ω–∞ {} {}").format(
                                                        contract, payload, message.successful_payment.currency)
                                                    )
                    await db.message("BOT", 10001, msg.html_text, msg.date)
                except Exception as err:
                    logging.exception(err)
        else:
            contract = await db.select_contract(message.from_user.id)
            contract = contract[0]
            payload = message.successful_payment.total_amount // 100
        if payload == 180:
            bill_id = data['bill_id_p180']
            await db.add_bill(
                bill_id, message.from_user.id, message.date, message.from_user.username, contract, payload)
        elif payload == 1080:
            bill_id = data['bill_id_p1080']
            await db.add_bill(
                bill_id, message.from_user.id, message.date, message.from_user.username, contract, payload)
        elif payload == 200:
            bill_id = data['bill_id_p200']
            await db.add_bill(
                bill_id, message.from_user.id, message.date, message.from_user.username, contract, payload)
        elif payload == 1200:
            bill_id = data['bill_id_p1200']
            await db.add_bill(
                bill_id, message.from_user.id, message.date, message.from_user.username, contract, payload)
        elif payload == 350:
            bill_id = data['bill_id_p350']
            await db.add_bill(
                bill_id, message.from_user.id, message.date, message.from_user.username, contract, payload)
        elif payload == 2100:
            bill_id = data['bill_id_p2100']
            await db.add_bill(
                bill_id, message.from_user.id, message.date, message.from_user.username, contract, payload)
        await database.pay_balance(contract=contract[0], payload=payload)
        msg = await dp.bot.send_message(chat_id=message.from_user.id,
                                        text=__("–í–∞—à —Ä–∞—Ö—É–Ω–æ–∫ –ø–æ–ø–æ–≤–Ω–µ–Ω–æ –Ω–∞ {} {}!").format(
                                            payload, message.successful_payment.currency),
                                        reply_markup=return_button)
        await db.message("BOT", 10001, msg.html_text, msg.date)
    except Exception as e:
        logging.error(f"–ü–æ–º–∏–ª–∫–∞ –ø—Ä–∏ –æ–±—Ä–æ–±—Ü—ñ –ø–ª–∞—Ç–µ–∂—É: {e}")
        error_msg = await dp.bot.send_message(chat_id=message.from_user.id,
                                              text=__(
                                                  "–ù–∞ –∂–∞–ª—å, –≤–∏–Ω–∏–∫–ª–∞ –ø–æ–º–∏–ª–∫–∞ –ø—Ä–∏ –æ–±—Ä–æ–±—Ü—ñ –ø–ª–∞—Ç–µ–∂—É. –ë—É–¥—å –ª–∞—Å–∫–∞, –∑–≤–µ—Ä–Ω—ñ—Ç—å—Å—è –¥–æ —Å–ª—É–∂–±–∏ –ø—ñ–¥—Ç—Ä–∏–º–∫–∏."),
                                              reply_markup=return_button)
        await db.message("BOT", 10001, error_msg.html_text, error_msg.date)
        for admin in ADMINS:
            await dp.bot.send_message(chat_id=admin,
                                      text=f"–ü–æ–º–∏–ª–∫–∞ –ø—Ä–∏ –æ–±—Ä–æ–±—Ü—ñ –ø–ª–∞—Ç–µ–∂—É –¥–ª—è –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞ {message.from_user.id}: {e}")
</file>

<file path="handlers/users/start.py">
import logging

import asyncpg
from aiogram import types
from aiogram.dispatcher import FSMContext
from aiogram.dispatcher.filters.builtin import CommandStart, Text, CommandHelp
from aiogram.types import CallbackQuery, ReplyKeyboardRemove, InlineKeyboardMarkup, InlineKeyboardButton

from data.config import ADMINS
from keyboards.default.buttons import tel_button, return_button, client_request, unknown_request_button
from keyboards.inline.callback_datas import start_callback
from keyboards.inline.start_keyboard import choice_lang
from loader import dp, db
from middlewares import _, __
from states.get_client import Client, Request
from utils.db_api import database
from utils.format_number import format_number
from utils.misc.find_in_bill import find


@dp.message_handler(CommandStart())
async def bot_start(message: types.Message):
    await db.message(message.from_user.full_name, message.from_user.id, message.text, message.date)
    await message.answer(text=_("–ü—Ä–∏–≤—ñ—Ç, {}!\n"
                                "–ë–æ—Ç –ø—Ä–∞—Ü—é—î –≤ —Ç–µ—Å—Ç–æ–≤–æ–º—É —Ä–µ–∂–∏–º—ñ").format(message.from_user.full_name),
                         reply_markup=ReplyKeyboardRemove())
    try:
        await db.add_user(
            full_name=message.from_user.full_name,
            username=message.from_user.username,
            telegram_id=message.from_user.id
        )
    except asyncpg.exceptions.UniqueViolationError:
        await db.select_user(telegram_id=message.from_user.id)

    await message.answer(text=_("–û–±–µ—Ä—ñ—Ç—å –∑—Ä—É—á–Ω—É –¥–ª—è –í–∞—Å –º–æ–≤—É!"),
                         reply_markup=choice_lang
                         )


@dp.message_handler(CommandHelp())
async def help_message(message: types.Message):
    await db.message(message.from_user.full_name, message.from_user.id, message.text, message.date)
    msg = await message.answer(
        text=_("@infoaura_bot - –±–æ—Ç –º–µ—Ä–µ–∂—ñ —ñ–Ω—Ç–µ—Ä–Ω–µ—Ç-–ø—Ä–æ–≤–∞–π–¥–µ—Ä–∞ –Ü–Ω—Ñ–æ–∞—É—Ä–∞.\n"
               "–ë–æ—Ç –ø—Ä–∏–∑–Ω–∞—á–µ–Ω–∏–π –¥–ª—è –¥–æ—Å—Ç—É–ø–Ω–æ–≥–æ —É–ø—Ä–∞–≤–ª—ñ–Ω–Ω—è–º –ø–æ—Å–ª—É–≥–∞–º–∏, –ø–æ–ø–æ–≤–Ω–µ–Ω–Ω—è —Ä–∞—Ö—É–Ω–∫—É —ñ –≤–∏–∫–ª–∏–∫—É —Ñ–∞—Ö—ñ–≤—Ü—è –¥–ª—è –≤–∏—Ä—ñ—à–µ–Ω–Ω—è –ª–æ–∫–∞–ª—å–Ω–∏—Ö –ø—Ä–æ–±–ª–µ–º –ö–ª—ñ—î–Ω—Ç–∞.\n"
               "–ü—Ä–æ–ø–æ–∑–∏—Ü—ñ—ó —Ç–∞ –∑–∞—É–≤–∞–∂–µ–Ω–Ω—è –ø–æ —Ä–æ–±–æ—Ç—ñ –±–æ—Ç–∞ –ø—Ä–æ—Å–∏–º–æ –ø–∏—Å–∞—Ç–∏ –Ω–∞ email: bot@infoaura.com.ua."),
        reply_markup=return_button)
    await db.message("BOT", 10001, msg.html_text, msg.date)


@dp.message_handler(state='get_phone')
async def get_phone_state(message: types.Message):
    text = _("–¢—Ä–µ–±–∞ –Ω–∞—Ç–∏—Å–Ω—É—Ç–∏ –Ω–∞ –∫–Ω–æ–ø–∫—É —â–æ–± –ø–µ—Ä–µ–¥–∞—Ç–∏ –Ω–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω—É")
    await message.answer(text=text, reply_markup=tel_button)
    await db.message(message.from_user.full_name, message.from_user.id, message.text, message.date)


@dp.callback_query_handler(start_callback.filter(lang=["RU", "UA", "EN"]))
async def lang_reply(call: CallbackQuery, state: FSMContext):
    await db.message(call.from_user.full_name, call.from_user.id, call.message.text, call.message.date)
    await db.set_lang(call.data[7:].lower(), call.from_user.id)
    await call.answer()
    msg = await call.message.edit_text(
        text=_(
            "–í–∏ –æ–±—Ä–∞–ª–∏ {}\n–¢–µ–ø–µ—Ä –≤—ñ–¥–ø—Ä–∞–≤—Ç–µ, –±—É–¥—å –ª–∞—Å–∫–∞, —Å–≤—ñ–π –Ω–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω—É, —â–æ–± –∑–Ω–∞–π—Ç–∏ –í–∞—à –æ–±–ª—ñ–∫–æ–≤–∏–π –∑–∞–ø–∏—Å —É –Ω–∞—à–æ–º—É –±—ñ–ª—ñ–Ω–≥—É",
            locale=call.data[7:].lower()).format(
            call.data[7:])
    )
    await db.message("BOT", 10001, msg.html_text, msg.date)
    msg1 = await call.message.answer(text=_("–ö–Ω–æ–ø–∫–∞ –¥–ª—è —Ü—å–æ–≥–æ –∑–Ω–∏–∑—É", locale=call.data[7:].lower()),
                                     reply_markup=tel_button)
    await db.message("BOT", 10001, msg1.html_text, msg1.date)
    await state.set_state("get_phone")


@dp.message_handler(content_types=types.ContentType.CONTACT, state="get_phone")
async def ua_tel_get(message: types.Message, state: FSMContext):
    await state.finish()
    await db.message(message.from_user.full_name, message.from_user.id, message.text, message.date)
    tel = message.contact.phone_number
    tel = format_number(tel)
    await db.update_phone_number(tel, message.from_user.id)
    await database.search_query(tel)
    for admin in ADMINS:
        await dp.bot.send_message(admin, text=f"–ù–æ–≤–∏–π –∫–ª—ñ—î–Ω—Ç: {message.from_user.full_name}, {message.from_user.id}\n"
                                              f"–ó –Ω–æ–º–µ—Ä–æ–º —Ç–µ–ª–µ—Ñ–æ–Ω—É: {tel}\n")
        if len(database.data) > 0:
            await dp.bot.send_message(admin, text=f"–ö–ª—ñ—î–Ω—Ç –∑–Ω–∞–π–¥–µ–Ω–∏–π –≤ –±—ñ–ª—ñ–Ω–≥—É, –π–æ–≥–æ –Ω–æ–º–µ—Ä –¥–æ–≥–æ–≤–æ—Ä—É "
                                                  f"{database.data[2]}\n")
        else:
            await dp.bot.send_message(admin, text=f"–ö–ª—ñ—î–Ω—Ç –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–∏–π –≤ –±—ñ–ª—ñ–Ω–≥—É\n")
    try:
        await db.set_contract(database.data[2], message.from_user.id)
    except IndexError:
        pass
    net_on = _("–£–≤—ñ–º–∫–Ω–µ–Ω–æ")
    net_off = _("–í–∏–º–∫–Ω–µ–Ω–æ")
    print(database.data)
    if len(database.data) > 0:

        net_pause = await database.check_net_pause(database.data[2])
        if net_pause is True and database.data[4] == "on":
            msg = await message.answer(text=_("–í–∞—à username: {}\n"
                                              "–ù–∞ –≤–∞—à–æ–º—É —Ä–∞—Ö—É–Ω–∫—É: {}\n"
                                              "–í–∞—à –Ω–æ–º–µ—Ä –¥–æ–≥–æ–≤–æ—Ä—É: {}\n"
                                              "–í–∞—à–µ –ü–Ü–ë: {}\n"
                                              "–°—Ç–∞–Ω –ø–æ—Å–ª—É–≥–∏: {}\n"
                                              "–í–∞—à –ø–∞–∫–µ—Ç: {}").format(
                database.data[0], database.data[1], database.data[2], database.data[3], net_on, database.data[5]),
                reply_markup=client_request)
            await db.message("BOT", 10001, msg.html_text, msg.date)

        else:
            msg = await message.answer(text=_("–í–∞—à username: {}\n"
                                              "–ù–∞ –≤–∞—à–æ–º—É —Ä–∞—Ö—É–Ω–∫—É: {}\n"
                                              "–í–∞—à –Ω–æ–º–µ—Ä –¥–æ–≥–æ–≤–æ—Ä—É: {}\n"
                                              "–í–∞—à–µ –ü–Ü–ë: {}\n"
                                              "–°—Ç–∞–Ω –ø–æ—Å–ª—É–≥–∏: {}\n"
                                              "–í–∞—à –ø–∞–∫–µ—Ç: {}").format(
                database.data[0], database.data[1], database.data[2], database.data[3], net_off, database.data[5]),
                reply_markup=client_request)
            await db.message("BOT", 10001, msg.html_text, msg.date)

    else:
        msg = await message.answer(
            text=_("–í–∫–∞–∑–∞–Ω–∏–π –Ω–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω—É –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–æ —É –Ω–∞—à–æ–º—É –±—ñ–ª—ñ–Ω–≥—É\n"
                   "–Ø–∫—â–æ –≤–∏ –±–∞–∂–∞—î—Ç–µ –ø—ñ–¥–∫–ª—é—á–∏—Ç–∏—Å—è - –∑–∞–ª–∏—à—Ç–µ –∑–∞—è–≤–∫—É –Ω–∞ –ø—ñ–¥–∫–ª—é—á–µ–Ω–Ω—è –Ω–∞—Ç–∏—Å–Ω—É–≤—à–∏ –∫–Ω–æ–ø–∫—É"),
            reply_markup=unknown_request_button)
        await db.message("BOT", 10001, msg.html_text, msg.date)


@dp.message_handler(Text(equals=["–ì–æ–ª–æ–≤–Ω–µ –º–µ–Ω—é", "–ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é", "Main menu"]), state="*")
async def main_menu(message: types.Message, state: FSMContext):
    await state.finish()
    await db.message(message.from_user.full_name, message.from_user.id, message.text, message.date)
    tel = await db.select_tel(user_id=message.from_user.id)
    await database.search_query(tel)
    try:
        await db.set_contract(database.data[2], message.from_user.id)
    except IndexError:
        pass
    net_on = __("–£–≤—ñ–º–∫–Ω–µ–Ω–æ")
    net_off = __("–í–∏–º–∫–Ω–µ–Ω–æ")
    ban = await db.get_ban()
    if message.from_user.id in ban:
        await message.answer(_("–í—ñ—Ç–∞—î–º–æ! –î–ª—è –∑–≤–µ—Ä–Ω–µ–Ω–Ω—è, –±—É–¥—å-–ª–∞—Å–∫–∞, —Å–∫–æ—Ä–∏—Å—Ç–∞–π—Ç–µ—Å—å –Ω–∞—à–∏–º email —Ç–µ—Ö–Ω—ñ—á–Ω–æ—ó –ø—ñ–¥—Ç—Ä–∏–º–∫–∏ support@infoaura.com.ua"))
    elif len(database.data) > 0:
        if await database.check_net_pause(database.data[2]) is True and database.data[4] == "on":
            if await db.is_alarm(message.from_user.id):
                message_alarm = await db.get_alarm_message(int(database.data[6]))
                if message_alarm is None:
                    message_alarm = await db.get_alarm_message(int(database.data[2]))
                await message.answer(f"<b>{message_alarm}</b>")
                msg = await message.answer(text=_("–í–∞—à username: {}\n"
                                                  "–ù–∞ –≤–∞—à–æ–º—É —Ä–∞—Ö—É–Ω–∫—É: {}\n"
                                                  "–í–∞—à –Ω–æ–º–µ—Ä –¥–æ–≥–æ–≤–æ—Ä—É: {}\n"
                                                  "–í–∞—à–µ –ü–Ü–ë: {}\n"
                                                  "–°—Ç–∞–Ω –ø–æ—Å–ª—É–≥–∏: {}\n"
                                                  "–í–∞—à –ø–∞–∫–µ—Ç: {}").format(
                    database.data[0], database.data[1], database.data[2], database.data[3], net_on, database.data[5]),
                    reply_markup=client_request)
                await db.message("BOT", 10001, msg.html_text, msg.date)
            else:
                msg = await message.answer(text=_("–í–∞—à username: {}\n"
                                                  "–ù–∞ –≤–∞—à–æ–º—É —Ä–∞—Ö—É–Ω–∫—É: {}\n"
                                                  "–í–∞—à –Ω–æ–º–µ—Ä –¥–æ–≥–æ–≤–æ—Ä—É: {}\n"
                                                  "–í–∞—à–µ –ü–Ü–ë: {}\n"
                                                  "–°—Ç–∞–Ω –ø–æ—Å–ª—É–≥–∏: {}\n"
                                                  "–í–∞—à –ø–∞–∫–µ—Ç: {}").format(
                    database.data[0], database.data[1], database.data[2], database.data[3], net_on, database.data[5]),
                    reply_markup=client_request)
                await db.message("BOT", 10001, msg.html_text, msg.date)
        else:
            if await db.is_alarm(message.from_user.id):
                message_alarm = await db.get_alarm_message(int(database.data[6]))
                if message_alarm is None:
                    message_alarm = await db.get_alarm_message(int(database.data[2]))
                await message.answer(f"<b>{message_alarm}</b>")
                msg = await message.answer(text=_("–í–∞—à username: {}\n"
                                                  "–ù–∞ –≤–∞—à–æ–º—É —Ä–∞—Ö—É–Ω–∫—É: {}\n"
                                                  "–í–∞—à –Ω–æ–º–µ—Ä –¥–æ–≥–æ–≤–æ—Ä—É: {}\n"
                                                  "–í–∞—à–µ –ü–Ü–ë: {}\n"
                                                  "–°—Ç–∞–Ω –ø–æ—Å–ª—É–≥–∏: {}\n"
                                                  "–í–∞—à –ø–∞–∫–µ—Ç: {}").format(
                    database.data[0], database.data[1], database.data[2], database.data[3], net_off, database.data[5]),
                    reply_markup=client_request)
                await db.message("BOT", 10001, msg.html_text, msg.date)
            else:
                msg = await message.answer(text=_("–í–∞—à username: {}\n"
                                                  "–ù–∞ –≤–∞—à–æ–º—É —Ä–∞—Ö—É–Ω–∫—É: {}\n"
                                                  "–í–∞—à –Ω–æ–º–µ—Ä –¥–æ–≥–æ–≤–æ—Ä—É: {}\n"
                                                  "–í–∞—à–µ –ü–Ü–ë: {}\n"
                                                  "–°—Ç–∞–Ω –ø–æ—Å–ª—É–≥–∏: {}\n"
                                                  "–í–∞—à –ø–∞–∫–µ—Ç: {}").format(
                    database.data[0], database.data[1], database.data[2], database.data[3], net_off, database.data[5]),
                    reply_markup=client_request)
                await db.message("BOT", 10001, msg.html_text, msg.date)
    else:
        msg = await message.answer(
            text=_("–í–∫–∞–∑–∞–Ω–∏–π –Ω–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω—É –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–æ —É –Ω–∞—à–æ–º—É –±—ñ–ª—ñ–Ω–≥—É\n"
                   "–Ø–∫—â–æ –≤–∏ –±–∞–∂–∞—î—Ç–µ –ø—ñ–¥–∫–ª—é—á–∏—Ç–∏—Å—è - –∑–∞–ª–∏—à—Ç–µ –∑–∞—è–≤–∫—É –Ω–∞ –ø—ñ–¥–∫–ª—é—á–µ–Ω–Ω—è –Ω–∞—Ç–∏—Å–Ω—É–≤—à–∏ –∫–Ω–æ–ø–∫—É"),
            reply_markup=unknown_request_button)
        await db.message("BOT", 10001, msg.html_text, msg.date)


@dp.message_handler(Text(equals=__("–ü–æ–≤—ñ–¥–æ–º–∏—Ç–∏ –ø—Ä–æ –ø—Ä–æ–±–ª–µ–º—É")))
async def request_for_ts(message: types.Message):
    await db.message(message.from_user.full_name, message.from_user.id, message.text, message.date)
    ban = await db.get_ban()
    tel = await db.select_tel(message.from_user.id)
    if await db.is_alarm(message.from_user.id):
        await database.search_query(tel)
        if len(database.data) > 0:
            message_alarm = await db.get_alarm_message(int(database.data[6]))
            if message_alarm is None:
                message_alarm = await db.get_alarm_message(int(database.data[2]))
            await message.answer(f"<b>{message_alarm}</b>")
    elif message.from_user.id in ban:
        await message.answer(
            _("–í—ñ—Ç–∞—î–º–æ! –î–ª—è –∑–≤–µ—Ä–Ω–µ–Ω–Ω—è, –±—É–¥—å-–ª–∞—Å–∫–∞, —Å–∫–æ—Ä–∏—Å—Ç–∞–π—Ç–µ—Å—å –Ω–∞—à–∏–º email —Ç–µ—Ö–Ω—ñ—á–Ω–æ—ó –ø—ñ–¥—Ç—Ä–∏–º–∫–∏ support@infoaura.com.ua"))
    else:
        msg = await message.answer(text=_("–í–≤–µ–¥—ñ—Ç—å –≤–∞—à–µ –ü–Ü–ë, –Ω–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω—É —Ç–∞ –æ–ø–∏—à—ñ—Ç—å –ø—Ä–æ–±–ª–µ–º—É"),
                                   reply_markup=ReplyKeyboardRemove())
        await db.message("BOT", 10001, msg.html_text, msg.date)
        await Request.first()


@dp.message_handler(state=Request.Quest)
async def tech_support_message(message: types.Message, state: FSMContext):
    await db.message(message.from_user.full_name, message.from_user.id, message.text, message.date)
    answer = message.text
    user = await db.select_user_by_id(message.from_user.id)
    async with state.proxy() as data:
        data["–ó–∞—è–≤–∫–∞"] = answer
        for admin in ADMINS:
            try:
                answer_reply = InlineKeyboardMarkup()
                answer_reply.add(InlineKeyboardButton(text="–í—ñ–¥–ø–æ–≤—ñ—Å—Ç–∏",
                                                      callback_data=f"answer {message.from_user.id}"))
                msg = await dp.bot.send_message(admin, f"–ó–∞–≤–∫–∞ –Ω–∞ –≤–∏–∫–ª–∏–∫ –º–∞–π—Å—Ç—Ä–∞: {data['–ó–∞—è–≤–∫–∞']}")
                msg1 = await dp.bot.send_message(admin, f"–ö–æ—Ä–∏—Å—Ç—É–≤–∞—á: {user[1]}"
                                                        f"\n–ù–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω—É: {user[5]}"
                                                        f"\n–ù–æ–º–µ—Ä –¥–æ–≥–æ–≤–æ—Ä—É: {user[6]}"
                                                        f"\n–¢–µ–ª–µ–≥—Ä–∞–º –Ü–î: {user[3]}",
                                                 reply_markup=answer_reply)
                await db.message("BOT", 10001, msg1.html_text, msg1.date)
                await db.message("BOT", 10001, msg.html_text, msg.date)

            except Exception as err:
                logging.exception(err)
    await state.reset_state()
    msg = await message.answer(text=_("–ó–∞—è–≤–∫–∞ –≤ –æ–ø—Ä–∞—Ü—é–≤–∞–Ω–Ω—ñ, —á–µ–∫–∞–π—Ç–µ –∑–≤'—è–∑–∫—É\n"
                                      "–ú–æ–∂–µ—Ç–µ –ø–æ–≤–µ—Ä–Ω—É—Ç–∏—Å—å —É –≥–æ–ª–æ–≤–Ω–µ –º–µ–Ω—é —Å–∫–æ—Ä–∏—Å—Ç–∞–≤—à–∏—Å—å –∫–Ω–æ–ø–∫–æ—é –∑–Ω–∏–∑—É"),
                               reply_markup=return_button)
    await db.message("BOT", 10001, msg.html_text, msg.date)


@dp.message_handler(Text(equals=__("–ó–∞–ª–∏—à–∏—Ç–∏ –∑–∞—è–≤–∫—É –Ω–∞ –ø—ñ–¥–∫–ª—é—á–µ–Ω–Ω—è")))
async def get_client(message: types.Message):
    await db.message(message.from_user.full_name, message.from_user.id, message.text, message.date)
    ban = await db.get_ban()
    if message.from_user.id in ban:
        await message.answer(
            _("–í—ñ—Ç–∞—î–º–æ! –î–ª—è –∑–≤–µ—Ä–Ω–µ–Ω–Ω—è, –±—É–¥—å-–ª–∞—Å–∫–∞, —Å–∫–æ—Ä–∏—Å—Ç–∞–π—Ç–µ—Å—å –Ω–∞—à–∏–º email —Ç–µ—Ö–Ω—ñ—á–Ω–æ—ó –ø—ñ–¥—Ç—Ä–∏–º–∫–∏ support@infoaura.com.ua"))
    else:
        msg = await message.answer(
            text=_("–í–≤–µ–¥—ñ—Ç—å –ü–Ü–ë —Ç–∞ –Ω–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω—É - –º–∏ –∑–≤'—è–∂–µ–º–æ—Å—å –∑ –í–∞–º–∏ –¥–ª—è –ø—ñ–¥–∫–ª—é—á–µ–Ω–Ω—è"),
            reply_markup=ReplyKeyboardRemove())
        await db.message("BOT", 10001, msg.html_text, msg.date)
        await Client.first()


@dp.message_handler(Text(equals=__("–ü—ñ–¥–∫–ª—é—á–∏—Ç–∏ –¥—Ä—É–≥–∞")))
async def connect_friend(message: types.Message):
    await db.message(message.from_user.full_name, message.from_user.id, message.text, message.date)
    ban = await db.get_ban()
    if message.from_user.id in ban:
        await message.answer(
            _("–í—ñ—Ç–∞—î–º–æ! –î–ª—è –∑–≤–µ—Ä–Ω–µ–Ω–Ω—è, –±—É–¥—å-–ª–∞—Å–∫–∞, —Å–∫–æ—Ä–∏—Å—Ç–∞–π—Ç–µ—Å—å –Ω–∞—à–∏–º email —Ç–µ—Ö–Ω—ñ—á–Ω–æ—ó –ø—ñ–¥—Ç—Ä–∏–º–∫–∏ support@infoaura.com.ua"))
    else:
        contract = await db.select_contract(message.from_user.id)
        user_data = await find(contract=contract[0][0])
        text = __("""<b>–ü—ñ–¥–∫–ª—é—á—ñ—Ç—å –¥—Ä—É–≥–∞ –¥–æ –Ω–∞—à–æ—ó –º–µ—Ä–µ–∂—ñ —ñ–Ω—Ç–µ—Ä–Ω–µ—Ç</b> - –æ—Ç—Ä–∏–º–∞–π—Ç–µ –Ω–∞ —Å–≤—ñ–π —Ä–∞—Ö—É–Ω–æ–∫ —Å—É–º—É –≤–∞—Ä—Ç–æ—Å—Ç—ñ –í–∞—à–æ–≥–æ –ø–æ—Ç–æ—á–Ω–æ–≥–æ —Ç–∞—Ä–∏—Ñ–Ω–æ–≥–æ –ø–ª–∞–Ω—É. –ü—Ä–∏ –æ—Ñ–æ—Ä–º–ª–µ–Ω–Ω—ñ –∑–∞—è–≤–∫–∏ –Ω–∞ –ø—ñ–¥–∫–ª—é—á–µ–Ω–Ω—è, –æ—Å–æ–±—ñ –ø–æ—Ç—Ä—ñ–±–Ω–æ –∑–∞–∑–Ω–∞—á–∏—Ç–∏ —Ä–µ–∫–≤—ñ–∑–∏—Ç–∏ –í–∞—à–æ–≥–æ –ø—ñ–¥–∫–ª—é—á–µ–Ω–Ω—è (–Ω–∞ –≤–∏–±—ñ—Ä: –Ω–æ–º–µ—Ä –¥–æ–≥–æ–≤–æ—Ä—É {} –∞–±–æ –∞–¥—Ä–µ—Å—É –ø—ñ–¥–∫–ª—é—á–µ–Ω–Ω—è {}). –ü—ñ—Å–ª—è —Ñ–∞–∫—Ç–∏—á–Ω–æ–≥–æ –ø—ñ–¥–∫–ª—é—á–µ–Ω–Ω—è ¬´–î—Ä—É–≥–∞¬ª –¥–æ –Ω–∞—à–æ—ó –º–µ—Ä–µ–∂—ñ –í–∞—à –æ—Å–æ–±–æ–≤–∏–π —Ä–∞—Ö—É–Ω–æ–∫ –±—É–¥–µ –∞–≤—Ç–æ–º–∞—Ç–∏—á–Ω–æ –ø–æ–ø–æ–≤–Ω–µ–Ω–æ –Ω–∞ —Å—É–º—É –≤–∞—Ä—Ç–æ—Å—Ç—ñ –í–∞—à–æ–≥–æ –ø–æ—Ç–æ—á–Ω–æ–≥–æ —Ç–∞—Ä–∏—Ñ–Ω–æ–≥–æ –ø–ª–∞–Ω—É. –ü—Ä–∏ –ø—ñ–¥–∫–ª—é—á–µ–Ω–Ω—ñ —Ç–∞–∫–æ–∂ –¥—ñ—î –∞–∫—Ü—ñ—è ¬´–ü–µ—Ä–µ—Ö—ñ–¥¬ª """)
        msg = await message.answer(text.format(user_data['contract'], user_data['address']), reply_markup=return_button)
        await db.message("BOT", 10001, msg.html_text, msg.date)


@dp.message_handler(state=Client.Quest)
async def request_client(message: types.Message, state: FSMContext):
    await db.message(message.from_user.full_name, message.from_user.id, message.text, message.date)
    answer = message.text
    user = await db.select_user_by_id(message.from_user.id)
    async with state.proxy() as data:
        data["–ó–∞—è–≤–∫–∞"] = answer
        for admin in ADMINS:
            try:
                answer_reply = InlineKeyboardMarkup()
                answer_reply.add(InlineKeyboardButton(text="–í—ñ–¥–ø–æ–≤—ñ—Å—Ç–∏",
                                                      callback_data=f"answer {message.from_user.id}"))
                msg = await dp.bot.send_message(admin, f"–ó–∞—è–≤–∫–∞ –Ω–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ: {data['–ó–∞—è–≤–∫–∞']}")
                msg1 = await dp.bot.send_message(admin, f"–ö–æ—Ä–∏—Å—Ç—É–≤–∞—á: {user[1]}"
                                                        f"\n–ù–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω—É: {user[5]}"
                                                        f"\n–ù–æ–º–µ—Ä –¥–æ–≥–æ–≤–æ—Ä—É: {user[6]}"
                                                        f"\n–¢–µ–ª–µ–≥—Ä–∞–º –Ü–î: {user[3]}",
                                                 reply_markup=answer_reply)
                await db.message("BOT", 10001, msg1.html_text, msg1.date)
                await db.message("BOT", 10001, msg.html_text, msg.date)

            except Exception as err:
                logging.exception(err)
    await state.reset_state()
    msg = await message.answer(text=_("–ó–∞—è–≤–∫–∞ –≤ –æ–ø—Ä–∞—Ü—é–≤–∞–Ω–Ω—ñ, —á–µ–∫–∞–π—Ç–µ –∑–≤'—è–∑–∫—É\n"
                                      "–ú–æ–∂–µ—Ç–µ –ø–æ–≤–µ—Ä–Ω—É—Ç–∏—Å—å —É –≥–æ–ª–æ–≤–Ω–µ –º–µ–Ω—é —Å–∫–æ—Ä–∏—Å—Ç–∞–≤—à–∏—Å—å –∫–Ω–æ–ø–∫–æ—é –∑–Ω–∏–∑—É"),
                               reply_markup=return_button)
    await db.message("BOT", 10001, msg.html_text, msg.date)
</file>

<file path="handlers/users/time_pay.py">
from aiogram import types
from aiogram.dispatcher.filters import Text

from data.config import ADMINS
from keyboards.default.buttons import return_button
from loader import dp, db
from middlewares import _, __
from utils.db_api import database


@dp.message_handler(Text(equals=__("–¢–∏–º—á–∞—Å–æ–≤–∏–π –ø–ª–∞—Ç—ñ–∂")))
async def time_pay(message: types.Message):
    await db.message(message.from_user.full_name, message.from_user.id, message.text, message.date)
    user = await db.select_contract(message.from_user.id)
    user = user[0]["contract"]
    ban = await db.get_ban()
    if message.from_user.id in ban:
        await message.answer(
            _("–í—ñ—Ç–∞—î–º–æ! –î–ª—è –∑–≤–µ—Ä–Ω–µ–Ω–Ω—è, –±—É–¥—å-–ª–∞—Å–∫–∞, —Å–∫–æ—Ä–∏—Å—Ç–∞–π—Ç–µ—Å—å –Ω–∞—à–∏–º email —Ç–µ—Ö–Ω—ñ—á–Ω–æ—ó –ø—ñ–¥—Ç—Ä–∏–º–∫–∏ support@infoaura.com.ua"))
    elif await database.t_pay(user):
        msg = await message.answer(text=_("–î–æ—Å—Ç—É–ø –≤ –Ü–Ω—Ç–µ—Ä–Ω–µ—Ç —Ä–æ–∑–±–ª–æ–∫–æ–≤–∞–Ω–æ –Ω–∞ 24 –≥–æ–¥–∏–Ω–∏!\n"
    "–†–∞—Ö—É–Ω–æ–∫ –ø–æ–ø–æ–≤–Ω–µ–Ω–æ –Ω–∞ {} –≥—Ä–Ω –Ω–∞ 24 –≥–æ–¥–∏–Ω–∏! –¢–µ–ø–µ—Ä –º–æ–∂–µ—Ç–µ –ø–æ–≤–µ—Ä–Ω—É—Ç–∏—Å—å —É –≥–æ–ª–æ–≤–Ω–µ –º–µ–Ω—é").format(database.time_pay_b[0]),
                                   reply_markup=return_button)
        await db.message("BOT", 10001, msg.html_text, msg.date)
        for admin in ADMINS:
            await dp.bot.send_message(admin, _("–ö–æ—Ä–∏—Å—Ç—É–≤–∞—á {} –≤–∏–∫–æ—Ä–∏—Å—Ç–∞–≤ —Ç–∏–º—á–∞—Å–æ–≤–∏–π –ø–ª–∞—Ç—ñ–∂!").format(user))
    else:
        msg = await message.answer(text=_("–í–∏ –Ω–µ –º–æ–∂–µ—Ç–µ –≤–∏–∫–æ—Ä–∏—Å—Ç–∞—Ç–∏ —Ç–∏–º—á–∞—Å–æ–≤–∏–π –ø–ª–∞—Ç—ñ–∂!\n"
                                          "–ö–æ—Ä–∏—Å—Ç—É–≤–∞—Ç–∏—Å—å —Ç–∏–º—á–∞—Å–æ–≤–∏–º –ø–ª–∞—Ç–µ–∂–µ–º –º–æ–∂–Ω–∞ —Ä–∞–∑ –Ω–∞ –º—ñ—Å—è—Ü—å!"),
                                   reply_markup=return_button)
        await db.message("BOT", 10001, msg.html_text, msg.date)
</file>

<file path="keyboards/__init__.py">
from . import default
from . import inline
</file>

<file path="keyboards/default/admin.py">
from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton, ReplyKeyboardMarkup, KeyboardButton

admin_keyboard = InlineKeyboardMarkup(row_width=2)
admin_keyboard.add(
    InlineKeyboardButton(text="–í—ñ–¥–ø—Ä–∞–≤–∏—Ç–∏ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è", callback_data="panel_send_message"),
    InlineKeyboardButton(text="–ú–µ–Ω—é –∞–±–æ–Ω–µ–Ω—Ç–∞", callback_data="account_menu"),
    InlineKeyboardButton(text="–ó–∞–±–ª–æ–∫—É–≤–∞—Ç–∏ —é–∑–µ—Ä–∞", callback_data="ban_account"),
    InlineKeyboardButton(text="–†–æ–∑–±–ª–æ–∫—É–≤–∞—Ç–∏ —é–∑–µ—Ä–∞", callback_data="unban_account"),
    InlineKeyboardButton(text="–ó–∞—Ä–µ—ç—Å—Ç—Ä—É–≤–∞—Ç–∏ –∞–≤–∞—Ä—ñ—é", callback_data="register_alarm"),
    InlineKeyboardButton(text="–†–µ–¥–∞–∫—Ç–æ—Ä –∞–≤–∞—Ä—ñ–π", callback_data="redactor_alarm"))

accept_message = InlineKeyboardMarkup()
accept_message.add(
    InlineKeyboardButton(text="–¢–∞–∫", callback_data="panel_send_message_accept"),
    InlineKeyboardButton(text="–ù—ñ", callback_data="panel_send_message_decline"))

accept_message_phone = InlineKeyboardMarkup()
accept_message_phone.add(
    InlineKeyboardButton(text="–¢–∞–∫", callback_data="panel_send_message_accept_phone"),
    InlineKeyboardButton(text="–ù—ñ", callback_data="panel_send_message_decline_phone"))

accept_sms = InlineKeyboardMarkup()
accept_sms.add(
    InlineKeyboardButton(text="–¢–∞–∫", callback_data="panel_send_sms_accept"),
    InlineKeyboardButton(text="–ù—ñ", callback_data="panel_send_sms_decline"))

back = ReplyKeyboardMarkup(resize_keyboard=True)
back.add(KeyboardButton(text="–ù–∞–∑–∞–¥"))

back_inline = InlineKeyboardMarkup()
back_inline.add(InlineKeyboardButton(text="–ù–∞–∑–∞–¥", callback_data="back"))

admin_account_menu = InlineKeyboardMarkup()
admin_account_menu.add(
    InlineKeyboardButton(text='–ó–º—ñ–Ω–∏—Ç–∏ –±–∞–ª–∞–Ω—Å', callback_data='admin_change_balance'),
    InlineKeyboardButton(text='–¢–∏–º—á–∞—Å–æ–≤–∏–π –ø–ª–∞—Ç—ñ–∂', callback_data='admin_temporary_payment'),
    InlineKeyboardButton(text='–ó–º—ñ–Ω–∏—Ç–∏ –ø–∞–∫–µ—Ç', callback_data='admin_change_paket'),
    InlineKeyboardButton(text='–Ü—Å—Ç–æ—Ä—ñ—è –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω—å', callback_data='message_history'))

search_choice = InlineKeyboardMarkup(row_width=2)
search_choice.add(InlineKeyboardButton(text='–ù–æ–º–µ—Ä –¥–æ–≥–æ–≤–æ—Ä—É', callback_data='search_contract'),
                  InlineKeyboardButton(text='–ù–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω—É', callback_data='search_phone'),
                  InlineKeyboardButton(text='–Ü–º\'—è', callback_data='search_name'),
                  InlineKeyboardButton(text='–ê–¥—Ä–µ—Å–∞', callback_data='search_address'))

grp_choice = InlineKeyboardMarkup(row_width=2)
grp_choice.add(
    InlineKeyboardButton(text='"–£–¥–∞–ª–µ–Ω–Ω—ã–µ"', callback_data='1'),
    InlineKeyboardButton(text='"–ê–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—ã"', callback_data='2'),
    InlineKeyboardButton(text='"–°–µ—Ä–≤–µ—Ä–∞"', callback_data='3'),
    InlineKeyboardButton(text='"VIP"', callback_data='4'),
    InlineKeyboardButton(text='"–ö—É—Ä–µ–Ω—ñ–≤–∫–∞ WhiteIPs"', callback_data='5'),
    InlineKeyboardButton(text='"–û—Å—Ç–∞–Ω–æ–≤–∫–∞"', callback_data='6'),
    InlineKeyboardButton(text='"–ü—Ä–∏–æ—Å—Ç–∞–Ω–æ–≤–∫–∞"', callback_data='7'),
    InlineKeyboardButton(text='"–°–∞–≤–µ–Ω–∫–∞ PON"', callback_data='8'),
    InlineKeyboardButton(text='"–°–ú–ê–†–¢ –ò–ü–¢–í"', callback_data='9'),
    InlineKeyboardButton(text='"WiFi –ö–∏–µ–≤"', callback_data='10'),
    InlineKeyboardButton(text='"WiFi –°–∞–≤–µ–Ω–∫–∞"', callback_data='11'),
    InlineKeyboardButton(text='"–ê–±–æ–Ω–µ–Ω—Ç—ã –ö–∏–µ–≤"', callback_data='12'),
    InlineKeyboardButton(text='"–ö—É—Ä–µ–Ω—ñ–≤–∫–∞ GreyIPs"', callback_data='13'))

redact_alarm = InlineKeyboardMarkup(row_width=2)
redact_alarm.add(
    InlineKeyboardButton(text='–í–∏–¥–∞–ª–∏—Ç–∏ –∞–≤–∞—Ä—ñ—ó', callback_data='delete_alarm'),
    InlineKeyboardButton(text='–ó–º—ñ–Ω–∏—Ç–∏ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è', callback_data='change_message_alarm'))
</file>

<file path="keyboards/default/buttons.py">
from aiogram.types import ReplyKeyboardMarkup, KeyboardButton

from middlewares import __

tel_button = ReplyKeyboardMarkup(resize_keyboard=True, keyboard=[
    [
        KeyboardButton(text=__("–í—ñ–¥–ø—Ä–∞–≤–∏—Ç–∏ –Ω–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω—É"),
                       request_contact=True),
        KeyboardButton(text=__("–ü–æ–ø–æ–≤–Ω–∏—Ç–∏ —Ä–∞—Ö—É–Ω–æ–∫"))
    ]
], one_time_keyboard=True)

request_button = ReplyKeyboardMarkup(resize_keyboard=True, keyboard=[
    [
        KeyboardButton(text=__("–ì–æ–ª–æ–≤–Ω–µ –º–µ–Ω—é")),
        KeyboardButton(text=__("–ó–∞–ª–∏—à–∏—Ç–∏ –∑–∞—è–≤–∫—É –Ω–∞ –ø—ñ–¥–∫–ª—é—á–µ–Ω–Ω—è"))
    ]
], one_time_keyboard=True)

unknown_request_button = ReplyKeyboardMarkup(resize_keyboard=True, keyboard=[
    [
        KeyboardButton(text=__("–ó–∞–ª–∏—à–∏—Ç–∏ –∑–∞—è–≤–∫—É –Ω–∞ –ø—ñ–¥–∫–ª—é—á–µ–Ω–Ω—è")),
        KeyboardButton(text=__("–ó–º—ñ–Ω–∏—Ç–∏ –º–æ–≤—É")),
        KeyboardButton(text=__("–ü–æ–ø–æ–≤–Ω–∏—Ç–∏ —Ä–∞—Ö—É–Ω–æ–∫"))
    ]
])

client_request = ReplyKeyboardMarkup(resize_keyboard=True, keyboard=[
    [
        KeyboardButton(text=__("–¢–∏–º—á–∞—Å–æ–≤–∏–π –ø–ª–∞—Ç—ñ–∂")),
        KeyboardButton(text=__("–ü–æ–ø–æ–≤–Ω–∏—Ç–∏ —Ä–∞—Ö—É–Ω–æ–∫")),
        KeyboardButton(text=__("–ó–º—ñ–Ω–∏—Ç–∏ –º–æ–≤—É"))
    ],
    [
        KeyboardButton(text=__("–ü–æ–≤—ñ–¥–æ–º–∏—Ç–∏ –ø—Ä–æ –ø—Ä–æ–±–ª–µ–º—É")),
        KeyboardButton(text=__("–ü—ñ–¥–∫–ª—é—á–∏—Ç–∏ –¥—Ä—É–≥–∞"))
    ]
], one_time_keyboard=True)

return_button = ReplyKeyboardMarkup(resize_keyboard=True, keyboard=[
    [
        KeyboardButton(text=__("–ì–æ–ª–æ–≤–Ω–µ –º–µ–Ω—é"))
    ]
], one_time_keyboard=True)

lang_change = ReplyKeyboardMarkup(resize_keyboard=True, keyboard=[
    [
        KeyboardButton(text="üá∫üá¶ UA"),
        KeyboardButton(text="üá∫üá∏ EN"),
        KeyboardButton(text="üá∑üá∫ RU")

    ]
], one_time_keyboard=True)

time_pay = ReplyKeyboardMarkup(resize_keyboard=True, keyboard=[
    [
        KeyboardButton(text=__("–¢–∏–º—á–∞—Å–æ–≤–∏–π –ø–ª–∞—Ç—ñ–∂"))
    ]
], one_time_keyboard=True)
</file>

<file path="keyboards/inline/callback_datas.py">
from aiogram.utils.callback_data import CallbackData

start_callback = CallbackData("choice", "lang")
</file>

<file path="keyboards/inline/start_keyboard.py">
from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton

from keyboards.inline.callback_datas import start_callback

choice_lang = InlineKeyboardMarkup(row_width=3,
                                   inline_keyboard=[
                                       [
                                           InlineKeyboardButton(
                                               text="üá∫üá¶ UA",
                                               callback_data=start_callback.new("UA")
                                           ),
                                           InlineKeyboardButton(
                                               text="üá∫üá∏ EN",
                                               callback_data=start_callback.new("EN")
                                           ),
                                           InlineKeyboardButton(
                                               text="üá∑üá∫ RU",
                                               callback_data=start_callback.new("RU")
                                           )
                                       ]
                                   ])
</file>

<file path="loader.py">
from aiogram import Bot, Dispatcher, types
from aiogram.contrib.fsm_storage.memory import MemoryStorage
from apscheduler.schedulers.asyncio import AsyncIOScheduler

from data import config
from utils.db_api.postgresql import Database


bot = Bot(token=config.BOT_TOKEN, parse_mode=types.ParseMode.HTML)
storage = MemoryStorage()
dp = Dispatcher(bot, storage=storage)
db = Database()
scheduler = AsyncIOScheduler()
</file>

<file path="middlewares/__init__.py">
from aiogram import Dispatcher
#  from aiogram.contrib.middlewares.logging import LoggingMiddleware


from loader import dp
from .throttling import ThrottlingMiddleware
from .language_middleware import ACLMiddleware, setup_middleware


if __name__ == "middlewares":
    #  dp.middleware.setup(LoggingMiddleware())
    dp.middleware.setup(ThrottlingMiddleware())
    i18n = setup_middleware(dp)
    _ = i18n.gettext
    __ = i18n.lazy_gettext
</file>

<file path="middlewares/language_middleware.py">
from typing import Tuple, Any

from aiogram import types
from aiogram.contrib.middlewares.i18n import I18nMiddleware
from data.config import I18N_DOMAIN, LOCALES_DIR
from loader import db, dp


async def get_lang(user_id):
    user = await db.select_lang(user_id)
    if user:
        return user


class ACLMiddleware(I18nMiddleware):
    async def get_user_locale(self, action, args):
        user = types.User.get_current()

        return await get_lang(user.id) or user.locale


def setup_middleware(dp):
    i18n = ACLMiddleware(I18N_DOMAIN, LOCALES_DIR)
    dp.middleware.setup(i18n)
    return i18n
</file>

<file path="middlewares/throttling.py">
import asyncio

from aiogram import types, Dispatcher
from aiogram.dispatcher import DEFAULT_RATE_LIMIT
from aiogram.dispatcher.handler import CancelHandler, current_handler
from aiogram.dispatcher.middlewares import BaseMiddleware
from aiogram.utils.exceptions import Throttled


class ThrottlingMiddleware(BaseMiddleware):
    """
    Simple middleware
    """

    def __init__(self, limit=DEFAULT_RATE_LIMIT, key_prefix='antiflood_'):
        self.rate_limit = limit
        self.prefix = key_prefix
        super(ThrottlingMiddleware, self).__init__()

    async def on_process_message(self, message: types.Message, data: dict):
        handler = current_handler.get()
        dispatcher = Dispatcher.get_current()
        if handler:
            limit = getattr(handler, "throttling_rate_limit", self.rate_limit)
            key = getattr(handler, "throttling_key", f"{self.prefix}_{handler.__name__}")
        else:
            limit = self.rate_limit
            key = f"{self.prefix}_message"
        try:
            await dispatcher.throttle(key, rate=limit)
        except Throttled as t:
            await self.message_throttled(message, t)
            raise CancelHandler()

    async def message_throttled(self, message: types.Message, throttled: Throttled):
        if throttled.exceeded_count <= 2:
            await message.reply("Too many requests!")
</file>

<file path="requirements.txt">
aiogram~=2.17.1
environs~=9.3.5
aiomysql~=0.0.22
asyncpg~=0.25.0
pybabel
asyncio~=3.4.3
aiohttp~=3.8.1
APScheduler~=3.9.1
transliterate~=1.10.2
</file>

<file path="states/get_client.py">
from aiogram.dispatcher.filters.state import State, StatesGroup


class Client(StatesGroup):
    Quest = State()


class Request(StatesGroup):
    Quest = State()
</file>

<file path="utils/__init__.py">
from . import db_api
from . import misc
from .notify_admins import on_startup_notify
</file>

<file path="utils/db_api/database.py">
import asyncio
import logging
import time
from datetime import datetime
from typing import Dict

import aiomysql
import pytz as pytz

from data import config

loop = asyncio.get_event_loop()
data = []
plan = []
time_pay_b = []


async def search_query(tel):
    conn = await aiomysql.connect(host=config.BILL_HOST, port=int(config.BILL_PORT),
                                  user=config.BILL_USER, password=config.BILL_PASS,
                                  db=config.BILL_NAME, loop=loop, charset="cp1251")
    cur = await conn.cursor()
    await cur.execute("SELECT name, balance, contract, fio, state, paket, grp "
                      "FROM `users` "
                      f"WHERE telefon LIKE '{tel}%' ")
    result = await cur.fetchall()
    data.clear()
    plan.clear()
    try:
        result = result[0]
        plan.append(result[5])
        await cur.execute('SELECT name FROM `plans2` WHERE id=%s', result[5])
        paket = await cur.fetchall()
        paket = paket[0]
        data.append(result[0])
        data.append(result[1])
        data.append(result[2])
        data.append(result[3])
        data.append(result[4])
        data.append(paket[0])
        data.append(result[6])

    except IndexError:
        result = None
    await cur.close()
    conn.close()


async def account_show(account) -> Dict:
    conn = await aiomysql.connect(host=config.BILL_HOST, port=int(config.BILL_PORT),
                                  user=config.BILL_USER, password=config.BILL_PASS,
                                  db=config.BILL_NAME, loop=loop, charset="cp1251")
    cur = await conn.cursor()
    await cur.execute("SELECT name, balance, contract, fio, state, paket "
                      "FROM `users` "
                      f"WHERE contract LIKE '{account}%' ")
    result = await cur.fetchall()
    result = result[0]
    result_dict = {'name': result[0],
                   'balance': result[1],
                   'contract': result[2],
                   'fio': result[3],
                   'state': result[4],
                   'paket': result[5]}
    await cur.execute('SELECT name FROM `plans2` WHERE id=%s', result_dict['paket'])
    paket = await cur.fetchall()
    paket = paket[0]
    result_dict['paket'] = paket[0]
    await cur.close()
    conn.close()
    return result_dict


async def balance(contract):
    conn = await aiomysql.connect(host=config.BILL_HOST, port=int(config.BILL_PORT),
                                  user=config.BILL_USER, password=config.BILL_PASS,
                                  db=config.BILL_NAME, loop=loop, use_unicode='cp1251')
    cur = await conn.cursor()
    await cur.execute("SELECT balance, paket FROM users WHERE contract=%s", contract)
    client_balance = await cur.fetchall()
    client_balance = client_balance[0]
    await cur.execute('SELECT price FROM `plans2` WHERE id=%s', client_balance[1])
    tariff = await cur.fetchall()
    tariff = tariff[0][0]
    inequality = tariff[0] - client_balance[0]
    if inequality >= tariff:
        return False
    else:
        return inequality


async def pay_balance_150(contract):
    conn = await aiomysql.connect(host=config.BILL_HOST, port=int(config.BILL_PORT),
                                  user=config.BILL_USER, password=config.BILL_PASS,
                                  db=config.BILL_NAME, loop=loop, use_unicode='cp1251')
    cur = await conn.cursor()
    await cur.execute(f"UPDATE users set balance = balance + 150 WHERE contract={contract}")
    await cur.close()
    conn.close()


async def balance_change(contract, cash):
    conn = await aiomysql.connect(host=config.BILL_HOST, port=int(config.BILL_PORT),
                                  user=config.BILL_USER, password=config.BILL_PASS,
                                  db=config.BILL_NAME, loop=loop, use_unicode='cp1251')
    cur = await conn.cursor()
    await cur.execute(f"UPDATE users set balance = {cash} WHERE contract={contract}")
    await cur.close()
    conn.close()


async def pay_balance(contract, payload):
    now_time = datetime.now(pytz.timezone('Europe/Kiev'))
    now_t = time.mktime(now_time.timetuple()) + now_time.microsecond / 1E6
    conn = await aiomysql.connect(host=config.BILL_HOST, port=int(config.BILL_PORT),
                                  user=config.BILL_USER, password=config.BILL_PASS,
                                  db=config.BILL_NAME, loop=loop, use_unicode='cp1251')
    cur = await conn.cursor()
    await cur.execute(
        f"SELECT paket, id FROM users WHERE contract={contract}")
    user = await cur.fetchall()
    try:
        user = user[0]
        paket = user[0]
        id = user[1]
    except IndexError:
        user = None
        logging.info("User not Found")
        return False
    if paket:
        await cur.execute(f"SELECT price FROM plans2 WHERE id = {paket}")
    price = await cur.fetchall()
    try:
        price = price[0]
    except IndexError:
        price = None
        logging.info("Price not find")
        return False
    await cur.execute(f"UPDATE users set balance = balance + {payload} WHERE contract={contract}")
    await cur.execute("INSERT INTO pays (mid,cash,time,admin,reason,coment) VALUES (%s, %s, %s, %s, %s, %s)",
                      (
                          (id),
                          (payload),
                          (now_t),
                          ('BOT'),
                          (str(now_t)),
                          ('Popolnenie via BOT')
                      ))
    await cur.execute(f"SELECT balance FROM users WHERE contract = {contract}")
    balance_n = await cur.fetchall()
    balance_n = balance_n[0][0]
    if balance_n >= price[0]:
        await cur.execute(f'UPDATE users set state="on" WHERE contract={contract}')
    await cur.close()
    conn.close()


async def t_pay(contract):  # –í—Ä–µ–º–µ–Ω–Ω—ã–π –ø–ª—Ç–∞–∂–µ–∂
    now_time = datetime.now(pytz.timezone('Europe/Kiev'))
    now_t = time.mktime(now_time.timetuple()) + now_time.microsecond / 1E6
    next_t = now_t + 86400

    conn = await aiomysql.connect(host=config.BILL_HOST, port=int(config.BILL_PORT),
                                  user=config.BILL_USER, password=config.BILL_PASS,
                                  db=config.BILL_NAME, loop=loop, charset='cp1251')
    cur = await conn.cursor()
    await cur.execute(
        f"SELECT t_pay, paket, srvs, contract, fio, telefon, start_day, balance, id FROM users WHERE contract={contract}")
    user = await cur.fetchall()
    try:
        user = user[0]
        time_pay = user[0]
        paket = user[1]
        my_srvs = user[2]
        my_contract = user[3]
        my_fio = user[4]
        my_telefon = user[5]
        my_start_day = user[6]
        old_balance = user[7]
        id = user[8]
    except IndexError:
        user = None
        logging.info("User not Found")
        return False

    if time_pay == 0:
        if paket:
            await cur.execute(f"SELECT price FROM plans2 WHERE id = {paket}")
        price = await cur.fetchall()
        try:
            price = int(price[0][0])
            print(price)
        except IndexError:
            price = None
            logging.info("Price not find")
            return False

        if old_balance > 0:
            balance = old_balance + price
        else:
            balance = -old_balance + price
        await cur.execute(
            f"INSERT INTO pays (mid, cash, time, bonus, admin, reason,coment,flag) VALUES ({id}, {price}, '{next_t}', 'y','BOT','Platej sozdan {now_t}','Razblokirovan na 24 chasa', 't');")
        await cur.execute(f"UPDATE users SET balance={balance} WHERE contract={contract}")
        await cur.execute(f"UPDATE users SET state='on' WHERE contract={contract}")
        await cur.execute(f"UPDATE users SET t_pay=1 WHERE contract={contract}")
        await cur.commit()
        time_pay_b.clear()
        time_pay_b.append(balance)
        return True
    else:
        return False


async def check_net_pause(contract):
    # IF TRUE, NETPAUSE IS OFF
    # IF FALSE, NETPAUSE IS ON
    conn = await aiomysql.connect(host=config.BILL_HOST, port=int(config.BILL_PORT),
                                  user=config.BILL_USER, password=config.BILL_PASS,
                                  db=config.BILL_NAME, loop=loop, use_unicode='cp1251')
    cur = await conn.cursor()
    await cur.execute(f"SELECT id FROM users WHERE contract = {contract};")
    id = await cur.fetchall()
    id = id[0]
    await cur.execute("SELECT data FROM netpause WHERE mid = %s", id)
    net = await cur.fetchall()
    try:
        if net[0][0] == 0:
            return True
        elif net[0][0] == 1:
            return False
        else:
            return False
    except IndexError:
        return True


async def tel_by_group(group: int = 8):
    conn = await aiomysql.connect(host=config.BILL_HOST, port=int(config.BILL_PORT),
                                  user=config.BILL_USER, password=config.BILL_PASS,
                                  db=config.BILL_NAME, loop=loop, use_unicode='cp1251')
    cur = await conn.cursor()
    await cur.execute(f"SELECT telefon FROM users WHERE grp = {group}")
    phone = await cur.fetchall()
    try:
        phone_array = []
        for i in phone:
            phone_array.append(i[0])
        return phone_array
    except Exception as e:
        print(e)
        pass

async def users_with_alarm(grp, street=None, street_number=None):
    conn = await aiomysql.connect(host=config.BILL_HOST, port=int(config.BILL_PORT),
                                  user=config.BILL_USER, password=config.BILL_PASS,
                                  db=config.BILL_NAME, loop=loop, use_unicode='cp1251')
    cur = await conn.cursor()
    users_with_alarm_contract = []
    if grp and street and street_number:
        pass
    elif grp:
        await cur.execute(f"SELECT contract FROM users WHERE grp = {grp}")
        users = await cur.fetchall()
        for user in users:
            users_with_alarm_contract.append(user[0])
    return users_with_alarm_contract


async def check_contract_exists(contract):
    conn = await aiomysql.connect(host=config.BILL_HOST, port=int(config.BILL_PORT),
                                  user=config.BILL_USER, password=config.BILL_PASS,
                                  db=config.BILL_NAME, loop=loop, use_unicode='cp1251')
    cur = await conn.cursor()
    await cur.execute(f"SELECT contract FROM users")
    contracts_in_db = await cur.fetchall()
    if (contract,) in contracts_in_db:
        return True
    else:
        return False
</file>

<file path="utils/db_api/postgresql.py">
from typing import Union

import asyncpg
from asyncpg import Connection
from asyncpg.pool import Pool

from data import config


class Database:

    def __init__(self):
        self.pool: Union[Pool, None] = None

    async def create(self):
        self.pool = await asyncpg.create_pool(
            user=config.DB_USER,
            password=config.DB_PASS,
            host=config.DB_HOST,
            database=config.DB_NAME
        )

    async def execute(self, command, *args,
                      fetch: bool = False,
                      fetchval: bool = False,
                      fetchrow: bool = False,
                      execute: bool = False
                      ):
        async with self.pool.acquire() as connection:
            connection: Connection
            async with connection.transaction():
                if fetch:
                    result = await connection.fetch(command, *args)
                elif fetchval:
                    result = await connection.fetchval(command, *args)
                elif fetchrow:
                    result = await connection.fetchrow(command, *args)
                elif execute:
                    result = await connection.execute(command, *args)
            return result

    async def create_table_users(self):
        sql = """
        CREATE TABLE IF NOT EXISTS users (
        id SERIAL PRIMARY KEY,
        full_name VARCHAR(255) NOT NULL,
        username VARCHAR(255) NULL,
        telegram_id BIGINT NOT NULL UNIQUE, 
        lang VARCHAR(5) NULL,
        phone_number VARCHAR(255) NULL, 
        contract VARCHAR(255) NULL      
        );
        """
        await self.execute(sql, execute=True)

    async def create_table_msg(self):
        sql = """
        CREATE TABLE IF NOT EXISTS messages (
        id SERIAL PRIMARY KEY,
        full_name VARCHAR(255) NOT NULL,
        telegram_id BIGINT NOT NULL,
        date TIMESTAMP NOT NULL,
        message VARCHAR(255) NULL
        ); 
        """
        await self.execute(sql, execute=True)

    async def create_table_alarm(self):
        sql = """
        CREATE TABLE IF NOT EXISTS alarm (
        alarm_id SERIAL PRIMARY KEY,
        message VARCHAR(255) NOT NULL,
        grp_alarm VARCHAR(255) NOT NULL,
        street varchar(255),
        street_number varchar(255)
        );
        """
        await self.execute(sql, execute=True)

    async def create_table_bill_check(self):
        sql = """
        CREATE TABLE IF NOT EXISTS bill_check (
        bill_id SERIAL PRIMARY KEY,
        telegram_id BIGINT NOT NULL,
        date TIMESTAMP NOT NULL,
        username varchar(255),
        contract varchar(255),
        pay_amount varchar(255)
        );
        """
        await self.execute(sql, execute=True)

    @staticmethod
    def format_args(sql, parameters: dict):
        sql += " AND ".join([
            f"{item} = ${num}" for num, item in enumerate(parameters.keys(),
                                                          start=1)
        ])
        return sql, tuple(parameters.values())

    async def add_user(self, full_name, username, telegram_id):
        sql = "INSERT INTO users (full_name, username, telegram_id) VALUES($1, $2, $3) returning *"
        return await self.execute(sql, full_name, username, telegram_id, fetchrow=True)

    async def message(self, full_name, telegram_id, message, date):
        sql = "INSERT INTO messages (full_name, telegram_id, message, date) VALUES ($1, $2, $3, $4)"
        return await self.execute(sql, full_name, telegram_id, message, date, execute=True)

    async def select_all_users(self):
        sql = "SELECT * FROM Users"
        return await self.execute(sql, fetch=True)

    async def select_user(self, **kwargs):
        sql = "SELECT * FROM Users WHERE "
        sql, parameters = self.format_args(sql, parameters=kwargs)
        return await self.execute(sql, *parameters, fetchrow=True)

    async def select_user_by_id(self, user_id):
        sql = "SELECT * FROM Users WHERE telegram_id=$1"
        return await self.execute(sql, user_id, fetchrow=True)

    async def select_lang(self, user_id):
        sql = "SELECT lang FROM users WHERE telegram_id=$1"
        return await self.execute(sql, user_id, execute=True, fetchval=True)

    async def select_contract(self, user_id):
        sql = "SELECT contract FROM users WHERE telegram_id=$1"
        return await self.execute(sql, user_id, execute=True, fetch=True)

    async def select_user_id_by_contract(self, contract):
        sql = 'SELECT telegram_id FROM users WHERE contract=$1'
        return await self.execute(sql, contract, fetch=True)

    async def select_tel(self, user_id):
        sql = "SELECT phone_number FROM users WHERE telegram_id=$1 "
        return await self.execute(sql, user_id, execute=True, fetchval=True)

    async def count_users(self):
        sql = "SELECT COUNT(*) FROM Users"
        return await self.execute(sql, fetchval=True)

    async def count_contract_users(self):
        sql = "SELECT COUNT(*) FROM users WHERE contract IS NOT NULL"
        return await self.execute(sql, fetchval=True)

    async def update_user_username(self, username, telegram_id):
        sql = "UPDATE Users SET username=$1 WHERE telegram_id=$2"
        return await self.execute(sql, username, telegram_id, execute=True)

    async def update_phone_number(self, phone_number, telegram_id):
        sql = "UPDATE Users SET phone_number=$1 WHERE telegram_id=$2"
        return await self.execute(sql, phone_number, telegram_id, execute=True)

    async def delete_users(self):
        await self.execute("DELETE FROM Users WHERE TRUE", execute=True)

    async def drop_users(self):
        await self.execute("DROP TABLE Users", execute=True)

    async def set_lang(self, lang, telegram_id):
        sql = "UPDATE users SET lang=$1 WHERE telegram_id=$2"
        await self.execute(sql, lang, telegram_id, execute=True)

    async def set_contract(self, contract, telegram_id):
        sql = "UPDATE users SET contract=$1 WHERE telegram_id=$2"
        await self.execute(sql, contract, telegram_id, execute=True)

    async def choose_contract(self):
        sql = "SELECT full_name, telegram_id, contract FROM users"
        return await self.execute(sql, execute=True, fetch=True)

    async def select_id_by_phone(self, phone_number):
        sql = "SELECT telegram_id FROM users WHERE phone_number=$1"
        return await self.execute(sql, phone_number, execute=True, fetch=True)

    async def get_phone_by_contract(self, contract):
        sql = "SELECT phone_number FROM users WHERE contract=$1"
        return await self.execute(sql, contract, fetchval=True)

    async def set_ban(self, telegram_id):
        sql = "UPDATE users SET ban=TRUE WHERE telegram_id=$1"
        return await self.execute(sql, int(telegram_id), execute=True)

    async def set_unban(self, telegram_id):
        sql = "UPDATE users SET ban=FALSE WHERE telegram_id=$1"
        return await self.execute(sql, int(telegram_id), execute=True)

    async def get_ban(self):
        sql = "SELECT telegram_id, contract FROM users WHERE ban=TRUE"
        rec_ban = await self.execute(sql, fetch=True)
        ban_list = [(i[0], i[1]) for i in rec_ban]
        return ban_list

    async def insert_alarm(self, message, grp_alarm):
        if grp_alarm is None:
            sql = "INSERT INTO alarm (message) VALUES ($1)"
            return await self.execute(sql, message, execute=True)
        else:
            sql = "INSERT INTO alarm (message, grp_alarm) VALUES ($1, $2)"
            return await self.execute(sql, message, grp_alarm, execute=True)

    async def get_alarm(self):
        sql = "SELECT * FROM alarm"
        return await self.execute(sql, fetch=True)

    async def change_alarm_message(self, message, alarm_id):
        sql = "UPDATE alarm SET message=$1 WHERE alarm_id=$2"
        return await self.execute(sql, message, alarm_id, execute=True)

    async def delete_alarm(self, alarm_id):
        sql = "DELETE FROM alarm WHERE alarm_id=$1"
        return await self.execute(sql, int(alarm_id), execute=True)

    async def set_alarm_for_users(self, contract):
        sql = "UPDATE users SET alarm=TRUE WHERE contract=$1"
        return await self.execute(sql, contract, execute=True)

    async def is_alarm(self, telegram_id):
        sql = "SELECT contract FROM users WHERE telegram_id=$1 and alarm=TRUE"
        alarm = await self.execute(sql, telegram_id, fetchval=True)
        if alarm:
            return True
        else:
            return False

    async def get_alarm_message(self, grp_alarm):
        sql = "SELECT message FROM alarm WHERE grp_alarm LIKE '%$1%'"
        return await self.execute(sql, str(grp_alarm), fetchval=True)

    async def add_bill(self, bill_id, telegram_id, date, username, contract, pay_amount):
        sql = ("INSERT INTO bill_check (bill_id, telegram_id, date, username, contract, pay_amount) VALUES"
               " ($1, $2, $3, $4, $5, $6)")
        return await self.execute(sql, bill_id, telegram_id, date, username, contract, pay_amount, execute=True)

    async def get_message_history(self, user_id, message_count: int = 10):
        sql = ("SELECT message FROM messages WHERE telegram_id=$1 ORDER BY date DESC LIMIT $2")
        return await self.execute(sql, user_id, int(message_count), fetch=True)
</file>

<file path="utils/format_number.py">
import time

from loader import db
from utils.db_api import database


def format_number(telegram_number: str):
    telegram_number = "".join(num for num in telegram_number if num not in " +()")[2:]
    r = telegram_number[:3]
    r1 = telegram_number[3:6]
    r2 = telegram_number[6:]
    r2 = r2[:2]
    r3 = telegram_number[8:]
    result = "{}-{}-{}-{}".format(r, r1, r2, r3)
    return result


def unformat_number(telegram_number: str):
    telegram_number = "".join(num for num in telegram_number)
    num1 = telegram_number[:3]
    num2 = telegram_number[4:7]
    num3 = telegram_number[8:10]
    num4 = telegram_number[11:]
    return "{}{}{}{}".format(num1, num2, num3, num4)


def number(phone_number: str):
    num1 = phone_number[:3]
    num2 = phone_number[3:6]
    num3 = phone_number[6:8]
    num4 = phone_number[8:]
    return "{}-{}-{}-{}".format(num1, num2, num3, num4)


async def format_text_account(text: dict) -> str:
    if text['state'] == 'off':
        text['state'] = '–ó–∞–±–ª–æ–∫–æ–≤–∞–Ω–æ'
    elif text['state'] == 'pause':
        text['state'] = '–ü–∞—É–∑–∞'
    else:
        text['state'] = '–ê–∫—Ç–∏–≤–Ω–∞'
    result = f"""–í–∞—à username: {text['name']}\n–ù–∞ –≤–∞—à–æ–º—É —Ä–∞—Ö—É–Ω–∫—É: {text['balance']}\n–í–∞—à –Ω–æ–º–µ—Ä –¥–æ–≥–æ–≤–æ—Ä—É: {text['contract']}\n–í–∞—à–µ –ü–Ü–ë: {text['fio']}\n–°—Ç–∞–Ω –ø–æ—Å–ª—É–≥–∏: {text['state']}\n–í–∞—à –ø–∞–∫–µ—Ç: {text['paket']}\n–í–∞—à–∞ –ê–¥—Ä–µ—Å–∞: {text['address']}"""
    return result


async def format_text_account_admin(text: dict) -> str:
    phone_bot = await db.get_phone_by_contract(text["contract"])
    if text['state'] == 'off':
        text['state'] = '–ó–∞–±–ª–æ–∫–æ–≤–∞–Ω–æ'
    elif text['state'] == 'pause':
        text['state'] = '–ü–∞—É–∑–∞'
    else:
        text['state'] = '–ê–∫—Ç–∏–≤–Ω–∞'
    result = f"""–í–∞—à username: {text['name']}\n–ù–∞ –≤–∞—à–æ–º—É —Ä–∞—Ö—É–Ω–∫—É: {text['balance']}\n–í–∞—à –Ω–æ–º–µ—Ä –¥–æ–≥–æ–≤–æ—Ä—É: {text['contract']}\n–í–∞—à ip: {text['ip']}\n–í–∞—à–µ –ü–Ü–ë: {text['fio']}\n–°—Ç–∞–Ω –ø–æ—Å–ª—É–≥–∏: {text['state']}\n–í–∞—à –ø–∞–∫–µ—Ç: {text['paket']}\n–í–∞—à–∞ –ê–¥—Ä–µ—Å–∞: {text['address']}\n–í–∞—à —Ç–µ–ª–µ—Ñ–æ–Ω: {text['telefon']}\n–¢–µ–ª–µ—Ñ–æ–Ω —â–æ –≤ –±–æ—Ç—ñ: {phone_bot}"""
    return result
</file>

<file path="utils/misc/__init__.py">
from .throttling import rate_limit
from . import logging
</file>

<file path="utils/misc/find_in_bill.py">
import aiomysql
import asyncio
import time

from data import config

loop = asyncio.get_event_loop()


async def find(contract=None, phone=None, name=None, address: list = None):
    conn = await aiomysql.connect(host=config.BILL_HOST, port=int(config.BILL_PORT),
                                  user=config.BILL_USER, password=config.BILL_PASS,
                                  db=config.BILL_NAME, loop=loop, charset="cp1251")
    cur = await conn.cursor()
    await cur.execute("SELECT name_street FROM `p_street`")
    streets = await cur.fetchall()
    streets = [street[0] for street in streets]
    print(streets)
    try:
        if address:
            if address[0] in streets:
                if len(address) <= 1:
                    for street in range(len(streets)):
                        if streets[street] == address[0]:
                            await cur.execute("SELECT name, balance, contract, fio, state, paket, telefon, ip "
                                              f"FROM `users` WHERE  street = %s", (street,))
                            result = await cur.fetchall()
                            break
                if len(address) <= 2:
                    for street in range(len(streets)):
                        if streets[street] == address[0]:
                            await cur.execute("SELECT name, balance, contract, fio, state, paket, telefon, ip "
                                              f"FROM `users` WHERE  street= %s AND house = %s", (street,
                                                                                                 address[1]))
                            result = await cur.fetchall()
                            break
                if len(address) <= 3:
                    for street in range(len(streets)):
                        if streets[street] == address[0]:
                            await cur.execute("SELECT name, balance, contract, fio, state, paket, telefon, ip "
                                              f"FROM `users` WHERE  street= %s AND house = %s"
                                              f" AND room = %s", (street, address[1], address[2]))
                            result = await cur.fetchall()
                            break
                else:
                    raise ValueError("Too many arguments")

    except TypeError as e:
        print(e)
    if contract:
        await cur.execute("SELECT name, balance, contract, fio, state, paket, telefon, street, house, room, ip, id "
                          "FROM `users` "
                          f"WHERE contract LIKE '{contract}%' ")
    if phone:
        await cur.execute("SELECT name, balance, contract, fio, state, paket, telefon, street, house, room, ip, id"
                          "FROM `users` "
                          f"WHERE telefon LIKE '%{phone}%' ")
    if name:
        sql = "SELECT name, balance, contract, fio, state, paket, telefon, street, house, room, ip, id " \
              "FROM `users` " \
              f"WHERE fio LIKE '%{name}%' "
        print(sql)
        await cur.execute(sql.encode('cp1251'))
    result = await cur.fetchall()
    print(result)

    if len(result) == 1:
        result = result[0]
        address = f"{streets[result[7] - 1]} {result[8]}, –∫–≤ {result[9]}"
        result_dict = {'name': result[0],
                       'balance': result[1],
                       'contract': result[2],
                       'fio': result[3],
                       'state': result[4],
                       'paket': result[5],
                       'telefon': result[6],
                       'ip': result[10],
                       'id': result[11],
                       'address': address}
        await cur.execute('SELECT name FROM `plans2` WHERE id=%s', result_dict['paket'])
        paket = await cur.fetchall()
        paket = paket[0]
        result_dict['paket'] = paket[0]
        await cur.execute("select stop_time from netpause where mid =%s ORDER BY `stop_time` DESC LIMIT 1;",
                          result_dict['id'])
        net_pause_epoch = await cur.fetchall()
        if net_pause_epoch:
            net_pause_epoch = net_pause_epoch[0]
            if net_pause_epoch[0] > int(time.time()):
                result_dict['state'] = 'pause'
            else:
                pass
        await cur.close()
        conn.close()
        return result_dict
    else:
        temp_list = []
        for i in result:
            result_temp = i
            address = f"{streets[result_temp[7] - 1]} {result_temp[8]}, –∫–≤ {result_temp[9]}"
            result_dict = {'name': result_temp[0],
                           'balance': result_temp[1],
                           'contract': result_temp[2],
                           'fio': result_temp[3],
                           'state': result_temp[4],
                           'paket': result_temp[5],
                           'telefon': result_temp[6],
                           'ip': result_temp[10],
                           'address': address}
            await cur.execute('SELECT name FROM `plans2` WHERE id=%s', result_dict['paket'])
            paket = await cur.fetchall()
            await cur.execute("select stop_time from netpause where mid =%s ORDER BY `stop_time` DESC LIMIT 1;",
                              result_dict['id'])
            net_pause_epoch = await cur.fetchall()
            if net_pause_epoch:
                net_pause_epoch = net_pause_epoch[0]
                if net_pause_epoch[0] > int(time.time()):
                    result_dict['state'] = 'pause'
                else:
                    pass
            temp_list.append(result_dict)
        await cur.close()
        conn.close()
        return temp_list


async def active_users(contract):
    conn = await aiomysql.connect(host=config.BILL_HOST, port=int(config.BILL_PORT),
                                  user=config.BILL_USER, password=config.BILL_PASS,
                                  db=config.BILL_NAME, loop=loop, charset="cp1251")
    cur = await conn.cursor()
    await cur.execute("SELECT balance, state, paket, grp, ip , id"
                      "FROM `users` "
                      f"WHERE contract LIKE '{contract}%' ")
    result = await cur.fetchall()
    result = result[0]
    balance = result[0]
    state = result[1]
    paket = result[2]
    grp = result[3]
    ip = result[4]
    id = result[5]
    epoch = int(time.time())
    await cur.execute("select stop_time from netpause where mid =%s ORDER BY `stop_time` DESC LIMIT 1;", id)
    net_pause_epoch = await cur.fetchall()
    net_pause_epoch = net_pause_epoch[0]
    await cur.execute('SELECT name FROM `plans2` WHERE id=%s', paket)
    paket = await cur.fetchall()
    paket = paket[0]
    await cur.close()

    conn.close()
    if grp == 1:
        return "–ë–ª–æ–∫."
    elif grp == 7 or net_pause_epoch[0] < epoch:
        return "–ü–∞—É–∑–∞"
    elif balance >= 0 and state == 'on':
        return "–ê–∫—Ç–∏–≤–Ω–∞"
    else:
        return "–ë–ª–æ–∫."
    # if state == 'on' and balance >= 0 and grp != 1:
    #     return "–ê–∫—Ç–∏–≤–Ω–∞"
    # elif state == 'off' and balance >= and grp != 1:
    #     return "–ë–ª–æ–∫."
    # elif state == 'off' and balance < 0 and grp != 1:
    #     return "–ë–ª–æ–∫."
    # elif grp == 1:
    #     return "–ë–ª–æ–∫."
    # elif grp == 7:
    #     return "–ü–∞—É–∑–∞"
    # else:
    #     return "–ë–ª–æ–∫."
</file>

<file path="utils/misc/logging.py">
import logging

logging.basicConfig(format=u'%(filename)s [LINE:%(lineno)d] #%(levelname)-8s [%(asctime)s]  %(message)s',
                    level=logging.INFO
                    # level=logging.DEBUG,  # –ú–æ–∂–Ω–æ –∑–∞–º–µ–Ω–∏—Ç—å –Ω–∞ –¥—Ä—É–≥–æ–π —É—Ä–æ–≤–µ–Ω—å –ª–æ–≥–≥–∏—Ä–æ–≤–∞–Ω–∏—è.
                    )
</file>

<file path="utils/misc/pay_load.py">
from dataclasses import dataclass
from typing import List

from aiogram.types import LabeledPrice

from data import config


@dataclass(frozen=True)
class Pay:
    title: str
    description: str
    start_parameter: str
    currency: str
    prices: List[LabeledPrice]
    provider_data: dict = None
    photo_url: str = None
    photo_size: int = None
    photo_width: int = None
    photo_height: int = None
    need_name: bool = False
    need_phone_number: bool = False
    need_email: bool = False
    need_shipping_address: bool = False
    send_phone_number_to_provider: bool = False
    send_email_to_provider: bool = False
    is_flexible: bool = False
    provider_token: str = config.PROVIDER_TOKEN

    def generate_invoice(self):
        return self.__dict__
</file>

<file path="utils/misc/sms_message.py">
import imaplib
import email
import datetime
import transliterate

import aiohttp
from asyncio import sleep

from loader import dp, db
from utils.format_number import unformat_number, number
from aiogram.utils.exceptions import UserDeactivated, BotBlocked


async def send_message_sms(phone: int = None, text: str = None):
    if phone is None or text is None:
        # credentials
        username = "contact@infoaura.com.ua"

        # decode format
        decode_format = "utf-8"

        # generated app password
        app_password = "^W7VCV<:'kKhBb9N"

        # https://www.systoolsgroup.com/imap/
        gmail_host = 'imap.gmail.com'

        # set connection
        mail = imaplib.IMAP4_SSL(gmail_host)

        # login
        mail.login(username, app_password)

        # select inbox
        mail.select("INBOX")

        # select specific mails
        _, selected_mails = mail.search(None, 'UNSEEN')

        # total number of mails from specific user
        print("Total Messages Unseen:", len(selected_mails[0].split()))

        # get all users from db
        await db.create()
        users = await db.select_all_users()
        users_phones = []
        users_id = []
        for i in range(len(users)):
            users_phones.append(unformat_number(str(users[i]['phone_number'])))
            users_id.append(users[i]['telegram_id'])

        # email to dict_list
        email_phone = []
        email_text = []
        for num in selected_mails[0].split():
            _, data = mail.fetch(num, '(RFC822)')
            _, bytes_data = data[0]

            # convert the byte data to message
            email_message = email.message_from_bytes(bytes_data)
            print("\n===========================================")

            # access data
            print("Subject: ", email_message["subject"])
            print("To:", email_message["to"])
            print("From: ", email_message["from"])
            print("Date: ", email_message["date"])
            for part in email_message.walk():
                if part.get_content_type() == "text/plain" or part.get_content_type() == "text/html":
                    message = part.get_payload(decode=True)
                    print("Message: \n", message.decode(decode_format))
                    print("==========================================\n")
                    email_phone.append(email_message["subject"])
                    email_text.append(message.decode(decode_format))
                    break

        for i in range(len(email_phone)):
            await sleep(30)
            if email_phone[i] in users_phones:
                try:
                    divider = email_text[i].find('-----')
                    print(number(email_phone[i]))
                    telegram_id = await db.select_id_by_phone(phone_number=number(email_phone[i]))
                    telegram_id = telegram_id[0]['telegram_id']
                    print(telegram_id)
                    if divider:
                        await dp.bot.send_message(telegram_id, email_text[i][divider + 5:])
                        await db.message("BOT", 10001, email_text[i][divider + 5:], datetime.datetime.now())
                        print("Message sent via bot to:", telegram_id)
                    else:
                        await dp.bot.send_message(telegram_id, email_text[i])
                        await db.message("BOT", 10001, email_text[i], datetime.datetime.now())
                        print("Message sent via bot to:", telegram_id)
                except UserDeactivated as e:
                    print("Message sent via sms to:", email_phone[i])
                    try:
                        divider = email_text[i].find('-----')
                        if divider:
                            message_sms_text = f"{email_text[i][:divider]}\nt.me/infoaura_bot"
                        else:
                            message_sms_text = f"{email_text[i]}\nt.me/infoaura_bot"
                        print(len(message_sms_text), " length of  string")
                        if len(message_sms_text) >= 70:
                            print('transliterate')
                            if divider:
                                email_text_t = transliterate.translit(email_text[i][:divider], 'uk', reversed=True)
                            else:
                                email_text_t = transliterate.translit(email_text[i], 'uk', reversed=True)
                            message_sms_text = f"{email_text_t}\nt.me/infoaura_bot"
                        else:
                            print("no transliterate")
                            if divider:
                                message_sms_text = f"{email_text[i][:divider]}\nt.me/infoaura_bot"
                            else:
                                message_sms_text = f"{email_text[i]}\nt.me/infoaura_bot"
                        await sleep(60)
                        async with aiohttp.ClientSession() as session:
                            print("Sending sms to:", email_phone[i],
                                  "with text:", message_sms_text,
                                  "length of string:", len(message_sms_text))
                            param = {'version': 'http',
                                     'login': '380936425274',
                                     "pass": "iw79izvy",
                                     "key": '6cf938587e0ed0d992566730169e82e229f097c7',
                                     'command': "send",
                                     'from': 'IAura',
                                     'to': f"{email_phone[i]}",
                                     'message': f'{message_sms_text}'}
                            async with session.request('http', "https://smsukraine.com.ua/api/http.php",
                                                       params=param) as sms:
                                print("SMS: ", await sms.text())
                    except Exception as e:
                        print(e)
                    continue
                except BotBlocked:
                    print("Message sent via sms to:", email_phone[i])
                    try:
                        divider = email_text[i].find('-----')
                        if divider:
                            message_sms_text = f"{email_text[i][:divider]}\nt.me/infoaura_bot"
                        else:
                            message_sms_text = f"{email_text[i]}\nt.me/infoaura_bot"
                        print(len(message_sms_text), " length of  string")
                        if len(message_sms_text) >= 70:
                            print('transliterate')
                            if divider:
                                email_text_t = transliterate.translit(email_text[i][:divider], 'uk', reversed=True)
                            else:
                                email_text_t = transliterate.translit(email_text[i], 'uk', reversed=True)
                            message_sms_text = f"{email_text_t}\nt.me/infoaura_bot"
                        else:
                            print("no transliterate")
                            if divider:
                                message_sms_text = f"{email_text[i][:divider]}\nt.me/infoaura_bot"
                            else:
                                message_sms_text = f"{email_text[i]}\nt.me/infoaura_bot"
                        await sleep(60)
                        async with aiohttp.ClientSession() as session:
                            print("Sending sms to:", email_phone[i],
                                  "with text:", message_sms_text,
                                  "length of string:", len(message_sms_text))
                            param = {'version': 'http',
                                     'login': '380936425274',
                                     "password": "iw79izvy",
                                     'command': "send",
                                     'from': 'IAura',
                                     'to': f"{email_phone[i]}",
                                     'message': f'{message_sms_text}'}
                            async with session.request('http', "https://smsukraine.com.ua/api/http.php",
                                                       params=param) as sms:
                                print("SMS: ", await sms.text())
                    except Exception as e:
                        print(e)
                    continue
            else:
                print("Message sent via sms to:", email_phone[i])
                try:
                    divider = email_text[i].find('-----')
                    if divider:
                        message_sms_text = f"{email_text[i][:divider]}\nt.me/infoaura_bot"
                    else:
                        message_sms_text = f"{email_text[i]}\nt.me/infoaura_bot"
                    print(len(message_sms_text), " length of  string")
                    if len(message_sms_text) >= 70:
                        print('transliterate')
                        if divider:
                            email_text_t = transliterate.translit(email_text[i][:divider], 'uk', reversed=True)
                        else:
                            email_text_t = transliterate.translit(email_text[i], 'uk', reversed=True)
                        message_sms_text = f"{email_text_t}\nt.me/infoaura_bot"
                    else:
                        print("no transliterate")
                        if divider:
                            message_sms_text = f"{email_text[i][:divider]}\nt.me/infoaura_bot"
                        else:
                            message_sms_text = f"{email_text[i]}\nt.me/infoaura_bot"
                    await sleep(60)
                    async with aiohttp.ClientSession() as session:
                        print("Sending sms to:", email_phone[i],
                              "with text:", message_sms_text,
                              "length of string:", len(message_sms_text))
                        param = {'version': 'http',
                                 'login': '380936425274',
                                 "password": "iw79izvy",
                                 'command': "send",
                                 'from': 'IAura',
                                 'to': f"{email_phone[i]}",
                                 'message': f'{message_sms_text}'}
                        async with session.request('http', "https://smsukraine.com.ua/api/http.php",
                                                   params=param) as sms:
                            print("SMS: ", await sms.text())
                except Exception as e:
                    print(e)
                    pass
    else:
        users = await db.select_all_users()
        users_phones = []
        users_id = []
        for i in range(len(users)):
            users_phones.append(unformat_number(str(users[i]['phone_number'])))
            users_id.append(users[i]['telegram_id'])
            if int(phone) in users_id:
                await dp.bot.send_message(int(phone), text)
                await db.message("BOT", 10001, text, datetime.datetime.now())
                print("Message sent via bot to:", int(phone))
                result = f"Message sent via bot to: {int(phone)}"
                return result
            elif phone in users_phones:
                telegram_id = await db.select_id_by_phone(phone_number=number(phone))
                telegram_id = telegram_id[0]['telegram_id']
                msg = await dp.bot.send_message(telegram_id, text)
                await db.message("BOT", 10001, text, datetime.datetime.now())
                print("Message sent via bot to:", telegram_id)
                result = f"Message sent via bot to: {telegram_id}"
                return result
        else:
            print("Message sent via sms to:", phone)
            try:
                message_sms_text = f"{text}\nt.me/infoaura_bot"
                print(len(message_sms_text), " length of  string")
                if len(message_sms_text) >= 70:
                    print('transliterate')
                    email_text_t = transliterate.translit(text, 'uk', reversed=True)
                    message_sms_text = f"{email_text_t}\nt.me/infoaura_bot"
                else:
                    print("no transliterate")
                    message_sms_text = f"{text}\nt.me/infoaura_bot"
                await sleep(60)
                async with aiohttp.ClientSession() as session:
                    print("Sending sms to:", phone,
                          "with text:", message_sms_text,
                          "length of string:", len(message_sms_text))
                    param = {'version': 'http',
                             'login': '380936425274',
                             "password": "iw79izvy",
                             'command': "send",
                             'from': 'IAura',
                             'to': f"{phone}",
                             'message': f'{message_sms_text}'}
                    async with session.request('http', "https://smsukraine.com.ua/api/http.php",
                                               params=param) as sms:
                        print("SMS: ", await sms.text())
                        return "SMS: " + await sms.text()
            except Exception as e:
                print(e)
                return e
</file>

<file path="utils/misc/throttling.py">
def rate_limit(limit: int, key=None):
    """
    Decorator for configuring rate limit and key in different functions.

    :param limit:
    :param key:
    :return:
    """

    def decorator(func):
        setattr(func, 'throttling_rate_limit', limit)
        if key:
            setattr(func, 'throttling_key', key)
        return func

    return decorator
</file>

<file path="utils/notify_admins.py">
import logging

from aiogram import Dispatcher

from data.config import ADMINS


async def on_startup_notify(dp: Dispatcher):
    for admin in ADMINS:
        try:
            await dp.bot.send_message(admin, "–ë–æ—Ç –ó–∞–ø—É—â–µ–Ω, –ø–æ–ø—Ä–æ–±—É–π /start")

        except Exception as err:
            logging.exception(err)


async def on_shutdown_notify(dp: Dispatcher):
    for admin in ADMINS:
        try:
            await dp.bot.send_message(admin, "–ë–æ—Ç –≤—ã–∫–ª—é—á–µ–Ω, –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏–µ –Ω–µ–≤–æ–∑–º–æ–∂–Ω–æ")

        except Exception as err:
            logging.exception(err)
</file>

<file path="utils/telnet.py">
import telnetlib

HOST = '10.0.1.5'
user = 'admin'
password = 'badeit'


def to_bytes(line):
    return bytes(line, "UTF-8") + b'/r'


def telnet_cable_test(host: str, port: str):
    with telnetlib.Telnet(host) as tn:
        tn.write(b"admin\r")
        tn.write(b'badeit\r')
        tn.read_until(b'#')
        result = {}
        if tn.read_until(b'#'):
            tn.write(to_bytes("enable"))
            tn.write(b'conf t\r\n')
            tn.read_until(b'#')
            command = 'interface ethernet 1/{}'.format(port)
            command_1 = 'show am interface ethernet 1/{}'.format(port)
            command_2 = 'show mac-address-table interface ethernet 1/{}'.format(port)
            command_3 = ' '.format(port)
            command_4 = 'virtual-cable-test'
            commands = [command, command_1, command_2, command_3, command_4]
            for command in commands:
                tn.write(to_bytes(command))
                output = tn.read_until(b"#", timeout=5).decode('utf-8')
                result[command] = output.replace('\r\n', '\n')
            tn.write(to_bytes('exit'))
            tn.write(to_bytes('exit'))
            tn.write(to_bytes('exit'))
            return result
        elif tn.read_until(b'>'):
            tn.write(to_bytes("enable"))
            tn.write(b'conf t\r\n')
            tn.read_until(b'>')
            command = 'interface ethernet 0/0/{}'.format(port)
            command_1 = 'show am interface ethernet 0/0/{}'.format(port)
            command_2 = 'show mac-address-table interface ethernet 0/0/{}'.format(port)
            command_3 = 'show interface ethernet 0/0/{} detail'.format(port)
            command_4 = 'virtual-cable-test'
            commands = [command, command_1, command_2, command_3, command_4]
            for command in commands:
                tn.write(to_bytes(command))
                output = tn.read_until(b">", timeout=5).decode('utf-8')
                result[command] = output.replace('\r\n', '\n')
            tn.write(to_bytes('exit'))
            tn.write(to_bytes('exit'))
            tn.write(to_bytes('exit'))
            return result
        else:
            print("Error")
            return "Error"


if __name__ == '__main__':
    print(telnet_cable_test(HOST, '4'))
</file>

</repository_files>
